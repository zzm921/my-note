### 计算机网络基础
#### 网络分层模型
##### osi七层模型
OSI七层模型是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能。
![](Pasted%20image%2020240118151434.png)
每次层都专注坐一件事，并且每层都需要使用下层提供的功能。
OSI七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不适用，而且有些功能在多个层中重复出现。
![](Pasted%20image%2020240118151445.png)
##### TCP/IP四层模型
TCP/IP四层模型是目前被广泛采用的一种模型，我们可以将TCP/IP模型看做是OSI七层模型的渐渐版本，由一下4层组成：
1. 应用层
2. 传输层
3. 网络层
4. 网络接口层
需要注意的是，我们并不能将TCP/IP四层模型和OSI七层模型王权精确的匹配起来，不过可以简单将两者对应起来。
![](Pasted%20image%2020240118151456.png)
##### 为什么网络要分层？
复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。
1. 各层之间相互独立：各层之间相互独立，隔层之间不需要关心其它层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了。这个和我们对开发时系统进行分层是一个道理。
2. 提高了灵活性和可替换性：每一层都可以用做合适的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行。并且，每一层都可以根据需要进行修改或替换，而不会影响到整个网络的接口。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。
3. 大问题化小：分层可以将负责的网络问题分解为许多比较小、接线比较请求简单的小问题来处理和解决。这使得负责的计算机网路系统变得易于设计，实现和标准化。这个和我们平时开发的时候，一般会将系统分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这个娇小的问题具有跟好的边界（目标和接口）定义。
#### 常见网络协议
##### 应用层常见协议
![](Pasted%20image%2020240118151545.png)
- http协议（超文本传输协议）
- smtp协议（简单邮件发送协议）
- pop3/imap（邮件接收协议）
- ftp（文件传输协议）
- telnet（远程登录协议）
- ssh（安全的网络传输协议）
- rtp（实时传输协议）
- dns（域名管理系统）
##### 传输层常见协议
![](Pasted%20image%2020240118151538.png)
- tcp（传输控制协议）：提供面向连接的可靠的数据传输服务。
- udp（用户数据协议）：提供无连接的，尽最大努力的数据传输服务（不保证数据传输的可靠性），简单高效。

##### 网络层常见协议
![](Pasted%20image%2020240118151553.png)
- IP（网际协议）：TCP/IP协议中最重要的协议之一，属于网络层协议，主要作用是定义数据包格式，对数据包进行路由和寻址，以便他们可以跨网络传播并达到正确的目的地。目前ip协议分为两种，ipv4和ipv6。
- ARP（地址解析协议）：ARP协议解决的是网络层和数据链路层地址之间的转换问题。因为ip数据报在物理传输上，总是知道下一跳（物理上的下一个地址）在哪里，但ip属于逻辑地址，而MAc地址才是物理地址，ARP协议解决ip地址转换成mac地址的一些问题。
- ICMP（互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用网络诊断和故障排除。如ping
- NAT（网络地址转换协议）：NAT协议的应用场景如同他的名称一样-网络地址转换，应用于内部网到外部网的地址转化过程中。具体地说，在一个小的子网内，各主机使用的是同一个lan下的ip地址，但在该lan外，在广域网WAN中，需要一个统一的IP地址来表示该LAN在整个Internet上的位置。
- OSPF（开放式最短路径优先协议）：一种内部网管协议，也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳的路径。
- RIP（陆游信息协议）：一种内部网管协议，也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径
- BGP（边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息的路由选择协议，具有较高的可拓展性和灵活性。

### HTTP
#### 从输入URL到页面展示到底发生了什么
![](Pasted%20image%2020240118151608.png)
```
上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议
```
总体来说分为以下几个过程
1. DNS解析
2. TCP连接
3. 发送HTTP请求
4. 服务器处理请求并返回HTTP报文
5. 浏览器解析渲染页面
6. 连接结束

#### HTTP常见状态码
![](Pasted%20image%2020240118151620.png)
#### HTTP Header中常见的字段有哪些
| 请求头字段名 | 说明 | 示例 |
| ---- | ---- | ---- |
| Accept | 能够接受的回应内容类型（Content-Types）。 | Accept: text/plain |
| Accept-Charset | 能够接受的字符集 | Accept-Charset：utf-8 |
| Accept-Datetime | 能够接受的按照时间来表示的版本 | Accept-Datetime：Thu, 31 May 2007 20:35:00 GMT |
| Accept-Encoding | 能够接受的编码方式列表。参考 HTTP 压缩。\| | Accept-Encoding: gzip, deflate |
| Accept-Language | 能够接受的回应内容的自然语言列表 | Accept-language:en_us |
| Authorzation | 用于超文本传输协议的认证的认证信息 | Authorization：Basic xxxxxxxx |
| Cache-Control | 用来指定在这次请求/响应链中所有的缓存机制都必须遵守的执行 | Cache-Control:no-cache |
| Connection | 该浏览器想要优先使用的连接类型 | Connection:keep-alive Connection:Upgrade |
| Content-Length | 以八位字节数组表示请求体的长度 | Content-Length：348 |
| Content-MD5 | 请求体的内容的二进制MD5散列值，已Base64彪马的结果 | Content-MD5：dfdfdfssdaf |
| Content-Type | 请求体的多媒体类型 | Content-Type: application/x-www-form-urlencoded |
| Cookie | 之前由服务器通过set-Cookie发送的一个超文本传输协议Cookie | Cookie: $Version=1; Skin=new; |
| Date | 发送该消息的日期和时间 | Date: Tue, 15 Nov 1994 08:12:31 GMT |
| Expect | 标明客户端要求服务器作出特定的行为 | Expect: 100-continue\| |
| From | 发送此请求的用户邮件地址 | From: [user@example.com](mailto:user@example.com) |
| Host | 服务器的域名，以及服务器说监听的传输控制嫌疑端口号。 | Host: [en.wikipedia.org:80](http://en.wikipedia.org/) |
| if-Match | 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。 | If-Match: “737060cd8c284d8af7ad3082f209582d” |
| if-Modified-Since | 允许在对应的内容未被修改的情况下返回304未修改 | If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT |
| If-None-Match | 允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ） | If-None-Match: “737060cd8c284d8af7ad3082f209582d” |
| If-Range | 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 | If-Range: “737060cd8c284d8af7ad3082f209582d” |
| If-Unmodified-Since | 仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。 | If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT |
| Max-Forwards | 限制该消息可被代理及网关转发的次数。 | Max-Forwards: 10 |
| Origin | 发起一个针对跨来源资源共享的请求 | Origin: [http://www.example-social-network.com](http://www.example-social-network.com/) |
| Pragma | 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 | Pragma: no-cache |
| Proxy-Authorization | 用来向代理进行认证的认证信息。 | roxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== |
| Range | 仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。 | Range: bytes=500-999 |
| Referer | 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。 | Referer: [http://en.wikipedia.org/wiki/Main_Page](https://en.wikipedia.org/wiki/Main_Page) |
| TE | 浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值； | TE: trailers, deflate |
| Upgrade | 要求服务器升级到另一个协议。 | Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 |
| User-Agent | 浏览器的浏览器身份标识字符串 | User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 |
| Via | 向服务器告知，这个请求是由哪些代理发出的。 | Via: 1.0 fred, 1.1 [example.comopen in new window](http://example.com/) (Apache/1.1) |
| Warning | 一个一般性的警告，告知，在实体内容体中可能存在错误。 | Warning: 199 Miscellaneous warning |
#### HTTP和HTTPS有什么区别
![](Pasted%20image%2020240118151712.png)
- 端口号：HTTP默认是80，HTTPS默认是443
- URL前缀：HTTP的前缀是http://  HTTPS的前缀是https://
- 安全性和资源消耗：HTTP协议运行在TCP上，所有传输的内容都是明文，客户端和服务器都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用堆成加密，但对称加密的秘钥用服务器方的整数进行分对称加密。所以说，HTTP安全性没有HTTPS搞，但HTTPS比HTTP耗费更多的服务器资源。
- SEO(搜索引擎优化)：搜索引擎通常会更秦岚使用HTTPS协议的网站，因为HTTPS能够提供更高的安全性和用户隐私保护。使用HTTPS协议的网站会优先被显示。
#### HTTP/1.0和HTTP/1.1的区别
![](Pasted%20image%2020240118151720.png)
- 连接方式：HTTP/1.0为短链接，HTTP/1.1支持长链接
- 状态码相应：HTTP/1.1中加入了大量的状态码
- 缓存机制：1.0中主要使用Header里的if-Modified-Since,Expires来作为缓存判断的标准。1.1则引入了更多缓存控制策略如：Entity tag，If-Unmodified-Since，if-Match，if-None-Match等
- 带宽：HTTP/1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP/1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接
- **Host 头（Host Header）处理** :HTTP/1.1 引入了 Host 头字段，允许在同一 IP 地址上托管多个域名，从而支持虚拟主机的功能。而 HTTP/1.0 没有 Host 头字段，无法实现虚拟主机。
#### HTTP/1.1和HTTP/2.0的区别
![](Pasted%20image%2020240118151726.png)
- 多路复用：2.0在同一连接上可以同时传输多个请求和相应，互不干扰。1.1则使用串行方式，每个请求和相应都需要独立的连接，而浏览器为了控制资源会有6-8个TCP连接的限制。这使得2.0在处理过个请求时更加高效，交少了网络延迟和提高性能。
- 二进制帧：2.0使用二级制帧进行数据传输，而1.1则使用文本格式的报文。二进制帧更加紧凑和高效，交少了传输的数据量和带宽消耗
- 头部压缩：1.1支持body压缩，header不支持压缩。2.0支持header压缩，使用了专门为了header压缩而设计的HPACK算法，减少了网络开销。
- 服务器推送：2.0支持服务器推送，可以在服务请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。1.1则需要客户端自己发送请求开获取相关资源。
 
HTTP/2.0 多路复用效果图
![](Pasted%20image%2020240118151735.png)
可以看到，HTTP/2.0 的多路复用使得不同的请求可以共用一个 TCP 连接，避免建立多个连接带来不必要的额外开销，而 HTTP/1.1 中的每个请求都会建立一个单独的连接。
#### HTTP/2.0和HTTP/3.0的区别
![](Pasted%20image%2020240118151744.png)
- 传输协议：2.0是基于TCP协议实现的，3.0新增了QUIC（Quick UDP Internet Connections）协议来实现可靠的传输，提供了TLS/SSL相当的安全性，具有较低的连接和传输延迟。UIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。
- 建立连接：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。
- 队头阻塞：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。
- 错误恢复：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。
- 安全性：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。
![](Pasted%20image%2020240118151750.png)
#### HTTP 是不保存状态的协议, 如何保存用户状态?
TTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们如何保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。

在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。
**Cookie 被禁用怎么办?**

最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。

#### URI 和 URL 的区别是什么?
- URI是统一资源标志服，可以唯一标识一个资源。
- URL是统一资源定位符，可以提供该资源路径。他是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。
#### Cookie和Session有什么区别

#### GET和POST的区别
GET 和 POST 是 HTTP 协议中两种常用的请求方法，它们在不同的场景和目的下有不同的特点和用法。一般来说，可以从以下几个方面来区分二者（重点搞清两者在语义上的区别即可）：
- 语义（主要区别）：GET 通常用于获取或查询资源，而 POST 通常用于创建或修改资源。
- 幂等：GET 请求是幂等的，即多次重复执行不会改变资源的状态，而 POST 请求是不幂等的，即每次执行可能会产生不同的结果或影响资源的状态。
- 格式：GET 请求的参数通常放在 URL 中，形成查询字符串（querystring），而 POST 请求的参数通常放在请求体（body）中，可以有多种编码格式，如 application/x-www-form-urlencoded、multipart/form-data、application/json 等。GET 请求的 URL 长度受到浏览器和服务器的限制，而 POST 请求的 body 大小则没有明确的限制。不过，实际上 GET 请求也可以用 body 传输数据，只是并不推荐这样做，因为这样可能会导致一些兼容性或者语义上的问题。
- 缓存：由于 GET 请求是幂等的，它可以被浏览器或其他中间节点（如代理、网关）缓存起来，以提高性能和效率。而 POST 请求则不适合被缓存，因为它可能有副作用，每次执行可能需要实时的响应。
- 安全性：GET 请求和 POST 请求如果使用 HTTP 协议的话，那都不安全，因为 HTTP 协议本身是明文传输的，必须使用 HTTPS 协议来加密传输数据。另外，GET 请求相比 POST 请求更容易泄露敏感数据，因为 GET 请求的参数通常放在 URL 中。
### WebScoket
#### 什么是WebSocket
WebSocket是一种基于TCP连接的双全工通信协议，即客户端和服务器可以同时发送和接收数据。
WebSocket 协议本质上是应用层的协议，用于弥补 HTTP 协议在持久通信能力上的不足。客户端和服务器仅需一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。
![](Pasted%20image%2020240118151805.png)
#### WebSocket和HTTP的区别
- WebSocket是一种双向实时通信协议，而HTTP是一种单向通信协议。并且，HTTP协议只能由客户端发起，服务器无法主动通知客户端。
- WebSocket使用ws://或wss://  HTTP是http://或https://
- WebSocket可以支持拓展，用户可以拓展协议，实现部分自定义协议，如支持压缩、加密等
- WebSocket通信数据格式比较清凉，用于协议控制数据包头部比较小，网路开销比较小。HTTP通信每次都需要携带完整的头部，网络开销比较大。
#### WebSocket的工作过程
1. 客户端向服务器发送一个HTTP请求，请求头包含 upgrade：websocket 和sec-wensocket-key等字段，表示要求升级协议为websocket
2. 服务器收请求后，进行协议升级操作，如果支持websocket，它将回复一个101状态码。响应头中包含 connection：upgrade和sec-wensocket-accept：xxx等字段，表示升级成功websocket协议
3. 客户端和服务器建立一个websocket连接，可以进行双向数据传输，数据以帧的形式传输，websocket会将消息拆分成多个数据帧。发送端将消息拆分成多个帧发送。接收端将接受到的帧重新组装成完整的消息。
4. 客户端或服务器可以中东发送一个关闭帧，表示要断开连接。另一方收到关闭帧后，也会回复一个关闭帧，然后双方关闭TCP连接。

### PING
#### PING的作用
ping命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。
#### ping的工作原理
ping基于网络层ICMP（Internet Control Message Protocol，互联网控制报文协议）协议，其主要的原理就是通过在网络上发送和接受ICMP报文实现的。
ICMP报文中包含了类型字段，用于标识ICMP报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：
- **查询报文类型**：向目标主机发送请求并期望得到响应。
- **差错报文类型**：向源主机发送错误信息，用于报告网络中的错误情况。
PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。
- PING 命令会向目标主机发送 ICMP Echo Request。
- 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。

### DNS
DNS（domain name system）域名管理系统，是用户使用浏览器访问网址后，使用的第一个重要协议。DNS主要解决的是域名和ip地址的映射问题。
![](Pasted%20image%2020240118151820.png)
在一台电脑上，可能存在浏览器DNS缓存，操作系统DNS缓存，路由器DNS缓存。如果以上缓存都查询不到，那么DNS就闪亮登场了。
目前DNS的设计采用的是分布式、层次数据库结构。DNS是应用层协议，她可以在TCP和UDP上运行，端口为53。
#### DNS服务器有哪些，根服务器有多少个
Dns服务器自底向上可以分为以下几个层级：
- 根DNS服务器。根DNS服务器提供TLD服务器的IP地址。目前世界上只有13组根服务器，我国境内目前没有。
- 顶级域DNS服务器（TLD服务器）。顶级域是指域名后缀为com、org、net、edu等。国家也有自己的顶级域，如uk、fr和ca。TLD服务器提供权威DNS服务器的IP地址。
- 权威DNS服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址
- 本地DNS服务器。每个ISP（网络服务器提供商）都有一个自己的本地DNS服务器。当主机发出DNS请求时，该请求会被发往本地DNS服务器，他骑着代理的作用，并将该请求转发到DNS层次机构中。严格来说，不属于DNS层级结构。

世界上并不是只有 13 台根服务器，这是很多人普遍的误解，网上很多文章也是这么写的。实际上，现在根服务器数量远远超过这个数量。最初确实是为 DNS 根服务器分配了 13 个 IP 地址，每个 IP 地址对应一个不同的根 DNS 服务器。然而，由于互联网的快速发展和增长，这个原始的架构变得不太适应当前的需求。为了提高 DNS 的可靠性、安全性和性能，目前这 13 个 IP 地址中的每一个都有多个服务器，截止到 2023 年底，所有根服务器之和达到了 600 多台，未来还会继续增加。

#### DNS解析过程

#### DNS 劫持了解吗？如何应对？

DNS 劫持是一种网络攻击，它通过修改 DNS 服务器的解析结果，使用户访问的域名指向错误的 IP 地址，从而导致用户无法访问正常的网站，或者被引导到恶意的网站。DNS 劫持有时也被称为 DNS 重定向、DNS 欺骗或 DNS 污染。
