### TCP如何保证传输的可靠性
1. 基于数据块传输：应用数据被分割成TCP认为最合适发送的数据块，再传输给网络层，数据块被称为报文段或段
2. 对失序数据包重新排序以及去重：TCP为了保证不发生丢包，给每个包一个序列号，有了序列号就能给收到的数据根据序列号排序，并去掉重复序列号的数据可以实现数据包的去重。
3. 校验和：TCP将保留首部和数据的校验和。这是一个端到端的检验和。目的是检测数据在传输过程中是否有变化。如果收到的信息有差错，TCP将丢弃这个报文段不确认收到此报文段。
4. 重传机制：在数据报丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP的重传机制主要有：基于计时器的重传、快速重传（基于接收端反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段和序列号范围，这样客户端就知道哪些数据包已经到达服务器了）、D-SACK（重复SACK，在SACK的基础上、额外携带信息，告知发送发有哪些数据包自己重复接受了）。
5. 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送缓冲区能接纳的数据。当接收方来不及处理发送方数据时，能提示发送方降低发送的速率，防止包丢失。TCP使用的流量控制协议是可变大小的滑动窗口协议。
6. 拥塞控制：当网络拥塞时，减少数据发送。TCP发送数据的时候，需要考虑两个因素：一是接收方的接受能力，二是网络拥塞成都。接收方的接受能力可以有滑动敞口表示，表示接收方还有多少缓冲区可以用来接受数据。网络的拥塞程度油拥塞窗口表示，他是发送方更具网络状况自己维护的一个值，表示发送方认为可以在网络传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的能力，也不会造成网络过度拥塞。
### TCP如何实现流量控制
**TCP利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接受。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

**为什么需要流量控制?** 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 **接收缓冲区(Receiving Buffers)** 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。

#### TCP发送窗口可以划分成四个部分：
1. 已经发送并且确认的TCP段（已发送并确认）
2. 已经发送并且没有确认的TCP段（已发送未确认）
3. 未发送但是接受方准备接受的TCP端（可以发送）
4. 未发送且接收方为准备接收的TCP段（不可发送）
TCP发送窗口如图
![[Pasted image 20240116170741.png]]
- **SND.WND**：发送窗口。
- **SND.UNA**：Send Unacknowledged 指针，指向发送窗口的第一个字节。
- **SND.NXT**：Send Next 指针，指向可用窗口的第一个字节。
**可用窗口大小** = `SND.UNA + SND.WND - SND.NXT` 。

#### TCP接收窗口可以划分成三部分
1. 已经接收并且确认的TCP段（接受并确认）
2. 等待接受且允许发送方发送的TCP段（可以接受未确认）
3. 不可以接受且不允许发送的TCP段（不可接受）
**TCP 接收窗口结构图示**：
![[Pasted image 20240116171033.png]]
**接收窗口的大小是根据接收端处理数据的速度动态调整的。** 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。

另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。

### TCP的拥塞控制是怎么实现的？
在某段时间，若对网络某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫做拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，设计到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有的因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制说要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。
![[Pasted image 20240117103620.png]]
为了进行拥塞控制，TCP发送方要维持一个拥塞窗口的状态变量。拥塞控制窗口的大小取决于网络的拥塞成都，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。
TCP的拥塞控制采用了四种算法，即慢开始、拥塞避免、快重传和快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理AQM），以减少网络拥塞的发生。
- 慢开始：慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络拥塞，因为现在还不知道符合的网络情况。经验表明，较好的方法是先探测一下，即由小到大主键增大发送窗口，也就是由小到大主键增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。
- 拥塞避免：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，没进过一个往返时间RTT就吧发送方的cwnd加1.
- 快重传和快恢复：在TCP/IP中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，他能快速恢复丢失的数据包。没有FRR如果数据包丢失了，TCP将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了FRR，如果接收机接收到了一个不按顺序的数据段，他会立即给发送端发送一个重复去人。如果发送端接收到三个重复确认，他会假定确认件支出的数据段丢失了，并立即重传这些丢失的数据段。有了FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效的工作。当有多个数据信息包在某一段很短的时间内丢失是，它则不能很有效的工作。

### ARQ协议
自动重传请求（Automatic Repeat-reQuest,ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之类没有收到确认信息ACK，他通常会重新发送，直到收到确认或者重试超过一定次数。
ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。
#### 停止等待ARQ协议
停止等待协议是为了实现可靠传输，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间，还没有收到ACK确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；
在停止等待协议中。若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。
**1) 无差错情况:**
发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。
**2) 出现差错情况（超时重传）:**
停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 **自动重传请求 ARQ** 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。
**3）确认丢失和确认迟到**
- **确认丢失**：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。
- **确认迟到**：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。
#### 连续ARQ协议
连续ARQ协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经确认收到了。
- **优点：** 信道利用率高，容易实现，即使确认丢失，也不必重传。
- **缺点：** 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息
### 超时重传如何实现？超时重传时间怎么确定？
当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发送一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就会被假设为已丢失并进行重传。
- RTT（Round Trip Time）：往返时间，也就是数据包从发出去到收到对应 ACK 的时间。
- RTO（Retransmission Time Out）：重传超时时间，即从数据发送时刻算起，超过这个时间便执行重传。
RTO 的确定是一个关键问题，因为它直接影响到 TCP 的性能和效率。如果 RTO 设置得太小，会导致不必要的重传，增加网络负担；如果 RTO 设置得太大，会导致数据传输的延迟，降低吞吐量。因此，RTO 应该根据网络的实际状况，动态地进行调整。

RTT 的值会随着网络的波动而变化，所以 TCP 不能直接使用 RTT 作为 RTO。为了动态地调整 RTO，TCP 协议采用了一些算法，如加权移动平均（EWMA）算法，Karn 算法，Jacobson 算法等，这些算法都是根据往返时延（RTT）的测量和变化来估计 RTO 的值。
