### 数据库命名规范
- 所有数据库对象名称必须使用小写字母，并用下划线分割。
- 所有的数据库对象名称禁止使用mysql保留关键字。
- 数据库对象的命名要能做到见名识意，并且最后不要超过32个字符
- 临时库必须以tmp_为前缀并以日期为后缀，备份表必须以bak_为前缀日期为后缀
- 所有存储相同数据的列明和列必须一致
### 数据库基本设计规范
#### 所有表必须使用InnoDB存储引擎
没有特出要求的情况下，所有表必须使用InnoDB存储引擎
Innodb支持事务，支持行级锁，更好的恢复性，高并发下性能更好
#### 数据库和表的字符集统一使用utf8
utf8兼容性更好，统一字符集可以避免由于字符集转换产生乱码，不同的字符集进行比较前需要进行转换造成索引失效，如果数据库中有存储emoji表情的需要，字符集需要采用utf8mb4字符集
#### 所有表和字段都需要添加注释
使用comment从句添加的列的备注，从一开始就进行数据字典的维护
#### 尽量控制但表数据量的大小，建议控制在500w以内
500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。
可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小
#### 谨慎使用 MySQL 分区表
分区表在物理上表现为多个文件，在逻辑上表现为一个表；
谨慎选择分区键，跨分区查询效率可能更低；
建议采用物理分表的方式管理大数据。
#### 经常一起使用的列放到一个表中
避免更多的关联操作
#### 禁止在表中建立预留字段
- 预留字段的命名很难做到见名识意
- 预留字段无法确认存储的数据类型，所以无法选择合适的类型。
- 对于刘字段类型的修改，会对表进行锁定
#### 禁止在数据库中存储文件这类大的二进制数据
在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。
#### 不要被数据库范式说束缚
一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度
#### 禁止在线上数据库做数据库压力测试

### 数据库字段设计规范
#### 优先选择符合存储需要的最小的数据类型
存储字节越小，占用空间也就越小，性能越好。
- 某些字符串可以转换成数字类型存储，比如ip地址
- 对于非负型的数据（如自增id，整形ip，年龄）来说，要优先使用无符号整形来存储
- 小数值类型（比如年龄、状态）优先使用tinyint类型 
#### 避免使用text，blob数据类型，最常见的text类型可以存储64k的数据
**a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。**

MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。

如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 `select *`而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。

**2、TEXT 或 BLOB 类型只能使用前缀索引**

因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的
#### 避免使用enum类型
- 修改该enum值需要使用alter语句
- enum类型的order by 操作效率低，需要额外操作
- enum数据类型存在一些限制 比如建议不需要使用数值作为enum的枚举值。 
#### 尽可能把所有的列定义为 not null
除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。
- 索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；
- 进行比较和计算时要对 NULL 值做特别的处理。
#### 一定不要用字符串存储日期

对于日期类型来说， 一定不要用字符串存储日期。可以考虑 DATETIME、TIMESTAMP 和 数值型时间戳。

这三种种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：

|类型|存储空间|日期格式|日期范围|是否带时区信息|
|---|---|---|---|---|
|DATETIME|5~8字节|YYYY-MM-DD hh:mm:ss[.fraction]|1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]|否|
|TIMESTAMP|4~7字节|YYYY-MM-DD hh:mm:ss[.fraction]|1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]|是|
|数值型时间戳|4字节|全数字如1578707612|1970-01-01 00:00:01之后的时间|否|

#### 同财务相关的金额类数据必须使用 decimal 类型

- **非精准浮点**：float,double
- **精准浮点**：decimal

decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据

不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。

#### 单表不要包含过多字段
如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。

### 索引设计规范
#### 限制每张表的索引数量，建议单张表索引不超过5个
#### 禁止使用全文索引
#### 禁止给表中的每一列都建立单独的索引
#### 没有InnoDb表必须有一个主键
#### 常见索引列建议
- 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列
- 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段
- 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好
- 多表 join 的关联列
#### 如何选择索引列的顺序
建立索引的目的是：希望通过索引进行数据查找，减少随机i/o，增加查询性能，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。
- 区分度最高的放在联合索引的最左测（区分度=列中不同值的数量/列的总行数）
- 尽量吧字段长度小的列放到联合索引的最左测(因为字段长度越小，一页能存储的数据量越大，io性能也就越好)
- 使用最频繁的列放到联合索引的左侧
#### 避免建立冗余索引和重复索引
- 重复索引示例：primary key(id)、index(id)、unique index(id)
- 冗余索引示例：index(a,b,c)、index(a,b)、index(a)
#### 对于频繁的查询优先考虑使用覆盖索引
覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引
- **避免 InnoDB 表进行索引的二次查询:** InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。
- **可以把随机 IO 变成顺序 IO 加快查询效率:** 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。
#### 索引set规则
**尽量避免使用外键约束**

- 不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引
- 外键可用于保证数据的参照完整性，但建议在业务端实现
- 外键会影响父表和子表的写操作从而降低性能