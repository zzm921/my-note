### 索引介绍
索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种循序好的数据结构。

索引的作用相当于书的目录。索引底层数据结构存在许多类型，常见的索引结构有：b树，b+树和hash，红黑树。在Mysql中，无论是InnoDB还是MyIsam都是用b+树作为索引结构。
### 索引的优缺点
优点
- 使用索引可以大大加快数据检索的速度，这也是创建索引的最主要原因。
- 通过创建唯一索引，可以保证数据库表中每一行数据都有唯一性。
缺点
- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改时，如果有索引，索引也需要动态的修改，会降低sql执行效率
- 索引需要使用物理文件存储，会耗费一定空间。
### 索引底层数据结构选型
#### Hash表

哈希表是键值对的集合，通过键可以快速去除对应的值，因此哈希表可以快速检索数据（接近O(1)）。
为何能够通过key快速取出value呢，原因在于哈希算法（也叫散列算法）。通过哈希算加法，我们可以快速找到key对应的index，找到index也就找到对应的value。

#### 二叉查找树(bst)
二叉查找树是一种基于二叉树的结构数据，他具有以下特点
1、左子树所有节点值均小于根节点的值
2、右子数所有节点的值均大于根节点的值
3、左右子树分别为二叉查找树

当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过1的时候，查询的时间复杂度为O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为O(N)。

也就是话，二叉查找树的性能非常依赖于他的平衡度，这就导致其不适合作为mysql底层索引的数据结构。

#### avl树
AVL树是自平衡二叉查找树。avl树的贴点是保证人和节点的左右子树高度之差不超过1，因此也被称为高度平衡二叉树，他的查找、插入和删除在平准和最坏情况下的时间复杂度都是logn

AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。

由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 **磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。**

实际应用中，AVL 树使用的并不多

#### 红黑树
红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：
1. 每个节点非红即黑
2. 根节点总是黑色的
3. 每个叶子节点都是黑色的空节点
4. 如果节点是红色的，则它的子节点必须是黑色的
5. 从根节点和叶节点或孔子节点的每条路径，必须包含相同数目的黑色节点。

#### b树和b+树
B 树也称 B-树,全称为 **多路平衡查找树** ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 `Balanced` （平衡）的意思。
目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。

**B 树& B+树两者有何异同呢？**

- B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。
- B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。
- B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。
- 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。

综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。

### 索引类型总结
按照数据结构维度划分：
- b树索引：Mysql里默认和最常用的索引类型。只有叶子节点存储value，非叶子节点只有指针和key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样。
- 哈希索引：类似键值对的形式，一次既可以定位
- RTree索引：一般不会使用，金支持geometry数据类型，优势在于范围拆招，效率较低，通常使用搜索引擎如elasticsearch代替，
- 全文索引：对文本的内容进行分词，进行搜索。目前只有char、varchar、text列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎代替。

按照底层存储方式角度划分：
- 聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB中的主键索引就属于聚簇索引。
- 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。

按照应用维度划分
- 主键索引：加速查询+列值唯一+表中只有一个。
- 普通索引：仅加速查询
- 唯一索引：加速查询+列值唯一
- 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值
- 联合所用：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。
- 全文索引：对文本的内容进行分词，进行搜索。目前只有char、varchar、text列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎代替。

### 主键索引
数据表的主键列表使用的就是主键索引。
一张数据表有且只能有一个主键，并且主键不能为null，不能重复
Mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引且不允许存在null值的字段，如果有，啧选择该字段为默认主键，否则InnoDB将会自动创建一个6Byte的自增主键。
![[Pasted image 20231024163130.png]]
### 二级索引
二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。
唯一索引，普通索引，前缀索引等索引属于二级索引。
1. 唯一索引：唯一索引也是一种约束。唯一索引是属性列不能重复出现的数据，但是允许为null，一张表允许创建多个唯一索引。简历唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. 普通索引：普通索引是唯一作用就是为了快速查询数据。一张表允许创建多个普通索引，并允许数据重复和null
3. 前缀索引：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引简历的数据更小，因为只取了前几个字符
4. 全文索引：全文索引主要是为了检索大文本数据中的关键字信息，是目前搜索引擎数据库使用的一种技术。
![[Pasted image 20231024170157.png]]
### 聚簇索引与非聚簇索引
#### 聚簇索引（聚集索引）
聚簇索引及索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB中的主键索引就属于聚簇索引。
在Mysql中，InnoDB引擎的表的.ibd文件就包含了该表的索引和数据，对于InnoDB引擎来说，该表的索引（b+树）的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。

聚簇索引的优缺点
优点：
- 查询速度非常快：聚簇索引的查询速度非常的快，因为整个b+树本身就是一颗多差平衡树，叶子节点也是有序的，定位到索引的节点，就相当于定位到数据。相比于非聚簇索引，聚簇索引少了一次读取数据i/o操作。
- 对排序查找和范围查找优化：聚簇索引对主键和排序查找和范围查找速度非常快。
缺点：
- 依赖于有序的数据：因为b+数是多路平衡树，如果索引的数据是有序的，那么就需要在插入时已排序，如果数据是整形还好，否则类似于字符串或uuid这种又长又难比较的数据，插入或查找的速度肯定比较慢。
- 更新代价打：如果对索引列的数据被修改是，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，索引对于主键索引来说，主键一般都是不可被修改的。
#### 非聚簇索引
非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。Mysql的MyISAM都是用的非聚簇索引。
非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。

非聚簇索引的又去打点
优点：
- 更新代价比聚簇索引要小。非聚簇索引的更新代价就没有聚簇索引那么大，非聚簇索引的叶子节点是不存放数据的
缺点：
- 依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据
- 可能会二次查询：这应该是非聚簇索引最大的缺点算了。当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。
![[Pasted image 20231024175505.png]]
### 覆盖索引和联合索引
#### 覆盖索引
如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为覆盖索引。我们知道InnoDB存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要回标，也就是要通过主键查找一次，这样就会比较慢。而覆盖索引就是吧要查询出的列和索引是对应的，不做回表操作。
覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。
#### 联合索引
使用表中的多个字段创建索引，也就是联合索引，也叫组合索引或复合索引。

#### 最左前缀匹配原则
最左前缀匹配原则指的是，在使用联合索引时，mysql会根据联合索引中的字段顺序，从左到右一次到查询条件中去匹配，如果查询条件中存在于联合索引最左测字段相匹配的字段，啧就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **`>`**、**`<`** ）才会停止匹配。对于 **`>=`**、**`<=`**、**`BETWEEN`**、**`like`** 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。

### 索引下推
索引下推是mysql5.6版本中提供的一箱索引优化功能，可以在非聚簇索引遍历过程中，对索引包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。

### 正确使用索引的一些建议
#### 选择合适的字段创建索引
- 不为null的字段：索引字段的数据应该尽量不为null，因为对于数据为null的字段，数据库比较难优化。如果字段被频繁查询，但又避免不了为null，建议使用0，1.true，false这样语义比较清晰的短值或短字符作为代替
- 被频繁查询的字段：我们创建索引的字段应该是查询操作非常频繁的字段
- 被作为条件查询的字段：被作为where条件查询的字段，应该被考虑建立索引
- 频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间
- 被经常频繁用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及表和表的关系。建立索引，提高多表连接查询的效率。
#### 被频繁更新的字段应该慎重建立索引
虽然索引能带来查询上的效率，但维护索引的成本也是不小的。如果一个字段不被经常查询，反而被经常修改，那么久更不应该在这种字段上建立索引
#### 限制每张表的索引数量
索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。
索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。
因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。
#### 尽可能的考虑建立联合索引而不是单列索引
因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。
#### 注意避免冗余索引
冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。
#### 字符串类型的字段使用前缀索引代替普通索引
前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。
#### 避免索引失效
索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：
- ~~使用 `SELECT *` 进行查询;~~ `SELECT *` 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;
- 创建了组合索引，但查询条件未遵守最左匹配原则;
- 在索引列上进行计算、函数、类型转换等操作;
- 以 `%` 开头的 LIKE 查询比如 `like '%abc'`;
- 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;
- 发生[隐式转换](https://github.com/zzm921/JavaGuide/blob/main/docs/database/mysql/index-invalidation-caused-by-implicit-conversion.md);
- ......