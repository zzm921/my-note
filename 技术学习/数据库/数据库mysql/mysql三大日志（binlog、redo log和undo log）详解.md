mysql日志主要包括错误日志，查询日志，慢查询日志，事务日志，二进制日志几大类。其中，比较重要的还要数二进制日志binlog（归档日志）和事务日志redo log（重做日志）和undo log（回滚日志）。
![[Pasted image 20231026181230.png]]
### redo log
redo log是InnoDB存储引擎独有的，他让mysql拥有了崩溃恢复能力。
比如 mysql示例宕机了，重启时，innodb存储引擎会试用redo log恢复数据，保证数据的持久性和完整性。
![[Pasted image 20231026181424.png]]
mysql中数据是以页为单位，你查询一条记录，会从硬盘吧一页的数据加载出来，加载出来的数据校数据页，会放到buffer pool中。
后续的查询都是先从buffer pool中找，没有命中再去硬盘加载，减少磁盘io开销，提升性能。
更新表数据的时候，也是如此，发现buffer pool里存在要更新的数据，就直接在buffer pool里更新。然后会把在某个数据页上做了什么修改 记录到重做日志缓存（redo log buffer）里，接着刷盘到redo log文件里面。
![[Pasted image 20231026182606.png]]
每条 redo 记录由“表空间号+数据页号+偏移量+修改数据长度+具体修改的数据”组成
#### 刷盘时机
InnoDB刷新重做日志的时机有几种情况：
- 事务提交：当事务提交时，log buffer里的redolog会被刷新到磁盘
- log buffer空间不足时：log  buffer中缓存的redo log已经占满了 log buffer总容量的大约一半左右，就需要把这些日志刷新到磁盘上
- 事务日志缓冲区慢：InnoDB使用事务日志缓冲区来暂时存储事务的重做日志条目。当缓冲区满时，会触发日志的刷新，将日志写入磁盘。
- checkpoint（检查点）：InnoDB定期汇之星检查点操作，将内存中的脏数据（已修改但尚未写入磁盘的数据）刷新到磁盘，并且会将对应的重做日志一同刷新，以确保数据的一致性。
- 后台刷新线程：InnoDB启动了一个后台线程，负责周期性的将脏页（已修改但尚未写入磁盘的数据也）刷新到磁盘，并将相关的重做日志一同刷新。
- 正常关闭服务器：mysql关闭的时候，redo log都会刷入到磁盘去。


### binlog
redo log是物理日志，记录的内容是在“某数据页上做了什么修改”，属于InnoDB存储引擎
binlog是逻辑日志，记录内容是语句的原始逻辑，属于mysql server层。
数据库的数据备份、主备、主主、主从都离不开binlog，需要依靠binlog来同步数据，保持数据一致性。
![[Pasted image 20231030173816.png]]
binlog会记录所有涉及更新数据的逻辑操作，并且是顺序写。

#### 记录格式
binlog日志有三种格式，可以通过binlog_format参数执行
- statment：记录sql语句原文
- row
- mixed
#### 写入机制
binlog的写入时机也非常简单，事务执行过程中，先把日志写到binlog cache，事务提交的时候，在把binlog cache写入到binlog文件中。

### 两阶段提交
redo log（重做日志）让InnoDB存储引擎拥有了崩溃恢复能力
binlog（归档日志）保证了mysql集群架构的数据一致性。
虽然它们都属于持久化的保证，但是侧重点不同。

在执行更新语句过程，会记录`redo log`与`binlog`两块日志，以基本的事务为单位，`redo log`在事务执行过程中可以不断写入，而`binlog`只有在提交事务时才写入，所以`redo log`与`binlog`的写入时机不一样。
![[Pasted image 20231030174238.png]]

### undo log
我们知道如果想要保证事务的原子性，就需要在异常发生时，对已经执行的操作进行**回滚**，在 MySQL 中，恢复机制是通过 **回滚日志（undo log）** 实现的，所有事务进行的修改都会先记录到这个回滚日志中，然后再执行相关的操作。如果执行过程中遇到异常的话，我们直接利用 **回滚日志** 中的信息将数据回滚到修改之前的样子即可！并且，回滚日志会先于数据持久化到磁盘上。这样就保证了即使遇到数据库突然宕机等情况，当用户再次启动数据库的时候，数据库还能够通过查询回滚日志来回滚将之前未完成的事务。

另外，`MVCC` 的实现依赖于：**隐藏字段、Read View、undo log**。在内部实现中，`InnoDB` 通过数据行的 `DB_TRX_ID` 和 `Read View` 来判断数据的可见性，如不可见，则通过数据行的 `DB_ROLL_PTR` 找到 `undo log` 中的历史版本。每个事务读到的数据版本可能是不一样的，在同一个事务中，用户只能看到该事务创建 `Read View` 之前已经提交的修改和该事务本身做的修改

