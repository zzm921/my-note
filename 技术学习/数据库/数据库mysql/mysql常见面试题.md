### MySQL基础
#### 什么是关系型数据库
关系型数据库(rdb)就是一种建立在关系模型基础上的数据库。关系模型表明了数据库中所存储的数据之间的关系。

关系型数据库汇总，我们的数据都被存放在各个表总，表中的每一行都存放了一条数据。

#### 什么是sql
sql是一种接过话查询语言。专门用来与数据库打交道，目的是提供一种从数据库读写数据的简单有效的方法。

#### 什么是mysql
mysql是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据。

#### mysql的优点
1. 成熟稳定，功能完善
2. 开源免费
3. 文档丰富
4. 开箱即用，操作简单，维护成本低
5. 兼容性好，支持常见的操作系统，支持多种开发语言
6. 社区活跃，生态完善。
7. 事务支持有线，InnoDB存储引擎默认使用REPEATABLE-READ并不会有任何性能损失，并且，InnoDB实现的REPEATABLE-READ隔离级别其实可以解决幻读问题发生。
8. 支持分库分表、读写分离、高可用。

#### mysql字段类型
- 数值类型：整形（TINYINT、SMALLINT、MEDIUMINT、int 和bigint）、浮点型(float、double)、定点型（decimal）
- 字符串类型：char、varchar、tinytext、text、meduimtext、longtext、tinyblob、blob、mediumblob、longblob
- 日期时间类型：year、time、date、datetime、timestamp
![[Pasted image 20231010140203.png]]
#### 证书类型的unsigned属性有什么用
mysql中的整数类型可以使用可选的unsigned属性来表示不允许负值的无符号整数。使用unsigned属性可以将整数的上限提高一倍，因为他不需要存储负数值。

例如， TINYINT UNSIGNED 类型的取值范围是 0 ~ 255，而普通的 TINYINT 类型的值范围是 -128 ~ 127。INT UNSIGNED 类型的取值范围是 0 ~ 4,294,967,295，而普通的 TINYINT 类型的值范围是 2,147,483,648 ~ 2,147,483,647。

#### char和varchar的区别
- char是定长字符串，varchar是变长字符串。
- char在存储时，会在右边填充空格以达到指定的长度，检索时会去掉空格。varchar在存储时需要使用1或者2个额外的字节记录字符串长度，检索时不需要处理。
- char更适合存储长度较短或者长度都差不多的字符串，礼服bcrypt算法、md5算法加密后的密码、身份证号。varchar类型适合存储长度不确定或者存在较大差异的字符串。
- char(m)和varchar(m)的m都代表能够保存的字符最大值，无论是字母、数字、还是中文都只占用一个字符。

#### varchar(100)和varchar(10)的区别
- varchar(10)和varchar(100)都是变长字符类型，表示能够存储最多10和100个字符。
- 虽说varchar(100)和varchar(10)能存储的字符范围不同，但二者存储相同的字符串，所占的磁盘存储空间是一样的。不过varchar（100）会消耗更多内存。这是因为varchar类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，varchar100是按照100这个长度来进行的，也就会小号更多内存
#### decimal和float/double的区别
decimal和float的区别是：decimal是定点数，float/double是浮点数。decimal可以存储精确的小数，float/double只能存储近似的小数值。

DECIMAL 用于存储具有精度要求的小数，例如与货币相关的数据，可以避免浮点数带来的精度损失。

#### 为什么不推荐使用text和blob
TEXT 类型类似于 CHAR（0-255 字节）和 VARCHAR（0-65,535 字节），但可以存储更长的字符串，即长文本数据，例如博客内容。

|类型|可存储大小|用途|
|---|---|---|
|TINYTEXT|0-255 字节|一般文本字符串|
|TEXT|0-65,535 字节|长文本字符串|
|MEDIUMTEXT|0-16,772,150 字节|较大文本数据|
|LONGTEXT|0-4,294,967,295 字节|极大文本数据|

BLOB 类型主要用于存储二进制大对象，例如图片、音视频等文件。

|类型|可存储大小|用途|
|---|---|---|
|TINYBLOB|0-255 字节|短文本二进制字符串|
|BLOB|0-65KB|二进制字符串|
|MEDIUMBLOB|0-16MB|二进制形式的长文本数据|
|LONGBLOB|0-4GB|二进制形式的极大文本数据|

在日常开发中，很少使用 TEXT 类型，但偶尔会用到，而 BLOB 类型则基本不常用。如果预期长度范围可以通过 VARCHAR 来满足，建议避免使用 TEXT。

数据库规范通常不推荐使用 BLOB 和 TEXT 类型，这两种类型具有一些缺点和限制，例如：
- 不能有默认值。
- 在使用临时表时无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》书中有提到）。
- 检索效率较低。
- 不能直接创建索引，需要指定前缀长度。
- 可能会消耗大量的网络和 IO 带宽。
- 可能导致表上的 DML 操作变慢。
#### datetime和timestamp的区别
- datatime没有时区信息，timestamp和时区有关
- timestamp只需要四个字节的存储空间，datetime需要8个字节的存储空间。
- timestamp表示的时间范围更小。
	- DATETIME：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59
	- Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59

#### null和‘’的区别
- null代表一个不确定的值，就算是两个null，他两也不一定相等。例如，`SELECT NULL=NULL`的结果为 false，但是在我们使用`DISTINCT`,`GROUP BY`,`ORDER BY`时,`NULL`又被认为是相等的。
- ''的长度是0，是不占空间的，而null是需要占空间的
- null会影响聚合函数的结果。`AVG`、`MIN`、`MAX` 等聚合函数会忽略 `NULL` 值。 `COUNT` 的处理方式取决于参数的类型。如果参数是 `*`(`COUNT(*)`)，则会统计所有的记录数，包括 `NULL` 值；如果参数是某个字段名(`COUNT(列名)`)，则会忽略 `NULL` 值，只统计非空值的个数。
- 查询null时，必须使用 is null 或者 is not null来判断。

#### boolean类型应该如何表示
MySQL 中没有专门的布尔类型，而是用 TINYINT(1) 类型来表示布尔值。TINYINT(1) 类型可以存储 0 或 1，分别对应 false 或 true。

### mysql基础架构
如图![[Pasted image 20231010142410.png]]
从上图可以看出，mysql主要由下面几个部分构成
- 连接器：身份认证和权限管理
- 查询缓存：执行查询语句的时候，会先查询缓存
- 分析器：没有命中缓存的话，sql语句会经过分析器，查看sql的意图，并检查sql语法是否正确。
- 优化器：按照mysql认为最有的方案执行。
- 执行器：执行语句，然后从存储引擎中返回数据。执行语句之前会判断是否有权限，没有则报错
- 插件时存储引擎：主要负责数据的存储和读取，采用的是插件式架构，支持innodb、myisam，memory等多种存储引擎
#### mysql存储引擎
##### mysql有哪些存储引擎，默认使用哪个
可以通过show engines命令来查看
![[Pasted image 20231010143136.png]]

mysql当前默认的存储引擎是InnoDB。并且，所有的存储引擎中只有InnoDB是事务性存储引擎，也就是说只有InnoDB支持事务。

##### mysql存储引擎架构
mysql存储引擎采用的插件式架构，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储于引擎以适应不同的场景。存储引擎是基于表，而不是基于数据库

##### MyISAM和InnoDB的区别
- 是否支持行级锁。MyISAM只有表级锁，而InnoDB执行行级锁和表级锁，默认为行级锁。
- 是否支持事务。MyISAM不提供事务支持，InnoDB提供事务支持，实现了sql标准定义了四个级别，具有提交和回滚事务的能力。并且，InnoDB默认使用 repeatable-read（可重读）隔离级别，是可以解决幻读问题发生的
- 是否支持外键。MyISAM不支持，InnoDB支持。外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！
- 是否支持数据库异常崩溃后安全恢复。MyISAM不支持，InnoDB支持。使用InnoDB的数据库在异常崩溃后，数据库重启的时候会保证数据库恢复到崩溃前的状态。这个回复过程依赖于redo log。
- 是否支持mvcc。MyISAM不支持，innod支持。
- 索引实现不一样。虽然MyISAM和InnoDB引擎都是使用b+tree作为索引结构，但两种实现方式不太一样。InnoDB引擎中，其数据本身就是索引文件。MyISAM索引文件和数据文件是分离的，其表数据文件本身就是按b+tree组织的一个索引文件，数的节点data保存完整数据结构。
- 性能差别。InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。
![[Pasted image 20231010144842.png]]
##### MyISAM和InnoDB如何选择
大部分情况下使用InnoDB存储引擎，在某些读密集的情况下，使用MyISAM也是可以的。

#### mysql索引

见专题
#### mysql查询缓存
执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用
`my.cnf` 加入以下配置，重启 MySQL 开启查询缓存
```
query_cache_type=1
query_cache_size=600000
```
MySQL 执行以下命令也可以开启查询缓存
```
set global  query_cache_type=1;
set global  query_cache_size=600000;
```
如上，**开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果**。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。
**查询缓存不命中的情况：**
1. 任何两个查询在任何字符上的不同都会导致缓存不命中。
2. 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。
3. 缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。
**缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。** 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，**还可以通过 `sql_cache` 和 `sql_no_cache` 来控制某个查询语句是否需要缓存：**
```
SELECT sql_no_cache COUNT(*) FROM usr;
```

#### mysql日志
MySQL 日志常见的面试题有：
- MySQL 中常见的日志有哪些？
- 慢查询日志有什么用？
- binlog 主要记录了什么？
- redo log 如何保证事务的持久性？
- 页修改之后为什么不直接刷盘呢？
- binlog 和 redolog 有什么区别？
- undo log 如何保证事务的原子性？
### mysql事务
#### 什么是事务
事务就是逻辑上的一组操作，要么都执行，要么都不执行。
#### 数据库事务
数据库事务可以保证多个对数据库操作构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功，要么全部不执行。
```
# 开启一个事务
START TRANSACTION;
# 多条 SQL 语句
SQL1,SQL2...
## 提交事务
COMMIT;
```
![数据库事务示意图](https://oss.javaguide.cn/github/javaguide/mysql/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%A4%BA%E6%84%8F%E5%9B%BE.png)
#### 事务特性
![[Pasted image 20231010150022.png]]
1. 原子性（atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用
2. 一致性（consisitency）：执行事务前后，数据保持一致。
3. 隔离性（isolation）：并发访问数据库时，一个用户的事务不被其他事务干扰，各并发事务之间的数据是独立的。
4. 持久性(durability)：一个事务被提交后。它对数据库中的数据改变是持久的。及时数据库发生故障也不应该对其有任何影响。
**只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！**
![AID->C](https://oss.javaguide.cn/github/javaguide/mysql/AID-%3EC.png)
#### 并发事务带来了哪些问题
##### 脏读（dirty read）
一个事务读取数据并对数据进行修改，这个修改对其他事务来说是可见的。及时当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有提交到数据库，那么第二个事务读取到的就是脏数据，这也是脏读的由来。![[Pasted image 20231010150830.png]]
##### 丢失修改（lost to modify）
在一个事务读取一个数据是，另一个事务也访问了该数据，那么在第一个数据中心修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失了。因此称为丢失修改。![[Pasted image 20231010151653.png]]
##### 不可重复读（Unrepeatable read）
在一个事务内多次读统一数据，在这个事务还没有结束时，另一个事务也访问了该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务也修改导致第一个事务两次读取的数据可能不一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。![[Pasted image 20231010153001.png]]
##### 幻读（Phantom read）
幻读与不可重复读类似。他发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了昏厥以西洋，所以称为幻读。![[Pasted image 20231010153121.png]]

#### sql标准定义了那些事务隔离级别
- read-uncommitted（读取未提交）：最低隔离级别，允许读取尚为提交的数据变更，可能会导致脏读、幻读、或不可重复读。
- read-committed（读取已提交）：允许读取并发事务已经提交的数据，可以阻止脏读，但幻读或不可重复读仍有可能发生。
- repeatable-read（可重复读）：对同一字段的多次读取结果都是一致的，除非是本身事务自己所修改的，可以阻止脏读和不可重复读，但幻读仍有可能发生。
- serializable（可串行化）：最高隔离级别，完全服从acid的隔离级别。所有事务依次逐个执行，这样事务之间就完成不可能产生干扰。

| 隔离级别|脏读|不可重复读|幻读|
| --- |--- |--- |--- |
|READ-UNCOMMITTED|√|√|√|
|READ-COMMITTED|×|√|√|
|REPEATABLE-READ|×|×|√|
|SERIALIZABLE|×|×|×|
#### mysql的隔离级别是基于锁实现的么？
mysql的隔离级别是基于锁和mvcc机制共同实现的。
serializable隔离级别是通过锁来实现。read-committed和repeatab-read隔离级别是通过mvcc实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读
#### mysql的默认隔离级别
默认隔离级别是 repeatable-read

### mysql锁
#### 表级锁和行级锁
MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。

行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。
##### 对比
- 表级锁：mysql中锁粒度最大的益中所，是针对非索引字段加的说，对当前操作的整张表加锁，实现简单，消耗资源少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。
- 行级锁：mysql中锁粒度最小的一种锁，是针对索引字段加的锁，只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁开销大，几所慢，会出现死锁

#### 行级锁使用注意事项
行级锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行update delete时，如果没有落到索引，就会导致对扫描到的所有行进行加锁
#### InnoDB有哪几种行锁
- 记录锁（record lock）：属于单个行记录上的锁
- 间隙锁（gap lock）：锁定一个范围，不包括记录本身
- 临键锁（next-key lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。

在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。
#### 共享锁和排它锁
不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：
- 共享锁（s锁）：又称为读锁，事务在读取记录的时候获取共享锁，允许多个事务同事获取
- 排它锁（x锁）：又称为写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同事获取。如果一个记录已经被加上了排他锁，那其他事务不能再对这条事务加上任何类型的锁。
由于 MVCC 的存在，对于一般的 `SELECT` 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。
```
# 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用
SELECT ... LOCK IN SHARE MODE;
# 共享锁 可以在 MySQL 8.0 中使用
SELECT ... FOR SHARE;
# 排他锁
SELECT ... FOR UPDATE;
```
#### 意向锁
如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。
意向锁是表级锁，共有两种：
- **意向共享锁（Intention Shared Lock，IS 锁）**：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。
- **意向排他锁（Intention Exclusive Lock，IX 锁）**：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。
**意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。**
意向锁之间是互相兼容的。

|IS 锁|IX 锁|
|---|---|---|
|IS 锁|兼容|兼容|
|IX 锁|兼容|兼容|

意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。

|IS 锁|IX 锁|
|---|---|---|
|S 锁|兼容|互斥 |
|X 锁|互斥|互斥 |
#### 当前读和快照度有什么区别
#### 自增锁
### mysql性能优化
#### 如何存储ip地址
可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。
MySQL 提供了两个方法来处理 ip 地址
- `INET_ATON()`：把 ip 转为无符号整型 (4-8 位)
- `INET_NTOA()` :把整型的 ip 转为地址
插入数据前，先用 `INET_ATON()` 把 ip 地址转为整型，显示数据时，使用 `INET_NTOA()` 把整型的 ip 地址转为地址显示即可。
