### redis基础
#### 什么是redis
redis是一个基于c语言开发的开源nosql数据库。与传统数据库不同的是，redis的数据保存在内存中，因此读写速度非常快，被广泛应用于分布式缓存方向。并且，redis存储的是kv键值对数据。

为了满足不同的业务场景，redis内置了多种数据类型实现(比如string、hash、sorted set、bitmap、hyperloglog、geo)。并且，redis还支持事务】持久化、lua脚本、多种开箱即用的集群方案。

![[Pasted image 20231103153452.png]]
redis没有外部依赖，linux和osx 是redis开发和测试醉倒的两种操作系统，官方推荐生产环境使用linux部署redis

#### redis为什么这么快
redis内部做了非常多的性能优化，比较重要的有一下三点
1、redis基于内存，内存的访问速度是磁盘的上千倍
2、redis基于reactor模式设计开发了一套高效的时间处理模型，主要是单线程事件循环和io多路复用
3、redis内置了多种优化过后的数据类型/结构实现，性能非常高。
#### 分布式缓存常见的技术选型方案有哪些
费不是欢唱使用比较多的是memcached和redis。一般使用redis
#### 说一下memcaches和reids的区别和共通点
##### 共同点
1. 都是基于内存的数据库，一般都用来当做缓存使用
2. 都有过期策略
3. 两者的性能都非常高
##### 区别
1. redis支持更丰富的数据类型。redis不仅仅支持简单的kv类型数据，同事还提供list ,set,zset,hash等数据结构存储。memcaches只支持简单的kv数据类型。
2. redis支持数据持久化，可以将内存中的数据保持在磁盘中，启动的时候可以再次加载进行使用，二memcached把数据都放在内存中。
3. redis有灾难恢复机制。以为可以把缓存中的数据持久化到磁盘上。
4. redis在服务器内存使用完之后，可以将不用的数据方到磁盘上。memcached会直接报错。
5. memcached没有原生集群模式，需要依靠客户端来实现往集群中写数据；但是redis原生支持cluster模式
6. memcached是多线程，费祖册io复用网络模型，redis使用单线程的多路io复用模型
7. redis支持发布订阅模式，lua脚本，事务等功能，memcached不支持。
8. Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除
为什么要用redis
1、高性能
2、高并发

### redis应用
#### redis除了做缓存，还能做什么
- 分布式锁：基于redisson来实现分布式锁。
- 限流：一般通过redis+lua脚本的方式来实现限流
- 消息队列：redis自带的list数据结构可以作为一个简单的队列使用
- 演示队列：redisson内置了延时队列
- 分布式session:利用string或hash数据类型保存session数据，所有的服务器都可以访问。
- 复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 Bitmap 统计活跃用户、通过 Sorted Set 维护排行榜。

### redis数据类型
- 五种基础数据类型：String字符串、List列表、Set集合、Hash散列、Zset有序结合
- 3中特殊数据类型：HyperLogLog基数统计、Bitmap位图、Geospatial地理位置

#### string的应用场景
string是redis中最简单同事也是最常用的一个数据类型。他还是一种而竟是安全的数据类型，可以用来 存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。

#### string还是hash
- string存储的是序列化后的对象数据，存放的是整个对象。hash是对对象的每个字段单独存储，可以获取部分字段的信息，也可以添加或者修改部分字段，节省网络流量。如果对象中的某些字段需要经常变动或者经常需要单独查询对象的中的个别字段信息，hash就非常合适。
- string存储相对于来说更省空间，缓存相同的数据的对象，string消耗是hash的一半。

#### string的底层实现是什么
redis是基于c语言编写的，但是redis的string类型的底层实现并不是c语言的字符串，而是自己编写的sds(simple dynamic string，简单动态字符串)来作为底层实现。

#### 购物车信息用string还是hash存储更好
由于购物车中的商品频繁修改和变动，购物车信息建议用hash存储
- 用户id为key
- 商品id为field，商品数量为value
![[Pasted image 20231111140153.png]]
用户购物车信息的维护
- 用户添加商品就是往hash里面增加新的field和value
- 查询购物车信息就是遍历对应的hash
- 更改上平数量直接修改对应的value值
- 删除商品就是删除hash中对应的field
- 清空购物车直接删除对应的key

#### 使用redis实现一个排行榜
reids中有一个叫做sorted set的数据类型经常被用来做各种排行榜，
相关的一些reids命令  zrange(从小到大排序)\zrevrange（从大到小排序）、zrevrank（指定元素排序）

#### set的应用场景
redis中set是一种无序集合，集合中的元素没有先后循序但都唯一，有点类似于java中的hashset。
set的常见应用场景
- 存放的数据不能重复的场景：网站uv统计、文章点赞、动态点赞等
- 需要获取多个数据源交集、并集、差集的场景：共同好友、共同粉丝、好友推荐、音乐推荐、订阅号推荐等
- 需要随机获取数据源中的元素的场景：抽奖系统、随机点名等

#### 使用set做抽奖系统
如果想要使用 `Set` 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：
- `SADD key member1 member2 ...`：向指定集合添加一个或多个元素。
- `SPOP key count`：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。
- `SRANDMEMBER key count` : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。


#### 使用Bitmap统计活跃用户
Bitmap存储的是连续的二进制数字，通过bitmap字需要一个bit位来表示某个元素对应的值或者状态，key就是对应元素的本身。

#### 使用HYperLogLog统计页面uv怎么做
使用HyperLogLog统计页面UV主要需要用到下面这两个命令：
- PFADD key element1 element2....：添加一个或多个元素到HyperLogLog中
- PFCOUNT KEY1 KEY2: 获取一个或者多个HyperLogLog的唯一技术。
1、将访问指定页面的每个用户 ID 添加到 `HyperLogLog` 中。
```
PFADD PAGE_1:UV USER1 USER2 ...... USERn
```
2、统计指定页面的 UV。
```
PFCOUNT PAGE_1:UV
```

### redis持久化机制

### redis线程模型
对于读写命名来说，redis一直是单线程模型。不过在redis4版本之后，引入了多线程来执行与一些大键值对的一步删除操作，redis6版本之后引入了多线程来处理网络请求（提高网络io读写性能）。
#### redis单线程模型
redis基于reactor模式设计开发了一套高效的事件处理模型，这套事件处理模型对应的是redis中的文件事件处理器。由于文件事件处理器是单线程方式运行，所以我们一般都是说redis是单线程模型。

redis基于reactor模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器。
- 文件事件处理器使用i/o多路复用程序来建通多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。
- 当被监听的套接字准备好执行连接应答、读取、写入、关闭等操作时，与操作相对的文件事件就会调整套接字之前关联好的事件处理器来处理这些事件。
虽然文件事件处理器以单线程方式运行，但通过使用i/o多路复用程序来监听多个套接字，文件事件处理器即实现了高性能的网络通信模型，有可以很好的与redis服务器中其他同样以单线程方式运行的模块进行对接，这包吃了redis内部单线程设计的简单性。

##### 既然是单线程，那怎么监听大量的客户端连接呢
redis通过io多路复用程序来监听来自客户端的大量连接（监听多个socket），他会将感兴趣的事件和类型(读写)注册到内核中并监听每个事件是否发生。
这样的好处非常明显：io多路复用技术的使用让redis不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗
文件事件处理器主要包含4个部分：
- 多个socket（客户端连接）
- io多路复用程序（支持多个客户端连接的关键）
- 文件事件分派器（将 socket 关联到相应的事件处理器）
- 事件处理器连接应答处理器、命令请求处理器、命令回复处理器）
![[Pasted image 20231114171702.png]]

#### redis后台线程
我们虽然经常说redis是单线程模型(主要模型是单线程完成的)，但实际还有一些后台线程用于执行一些比较耗时的操作：
- 通过bio_close_file 后台线程来释放aof/rdb等过程中产生临时文件资源
- 通过bio_aof_fsync后台线程来调用fsync函数将系统内核缓冲区还未同步到磁盘的数据强制刷到磁盘(aof文件)
- 通过bio_lazy_free后台相乘释放都地向占用的内存空间

### redis内存管理
#### redis给缓存数据设置过期时间有啥用
一般情况下，我们设置保存缓存数据的时候都会设置一个过期时间。
因为内存是有限的，如果魂村中的所有数据都是一直保存的话，分分钟直接out of memory。
redis自带了给缓存数据设置过期时间的功能。
注意：redis中除了字符串类型有自己独有设置过期时间的命令 setex外，其他方法都需要依靠expire命令来设置过期时间。另外，persist命令可以移除一个键的过期时间。

#### redis是如何判断数据是否过期
redis通过一个叫做过期词典(可以看作是hash表)来保存数据过期时间。过期词典的键指向redis数据库中的某个key，过期词典的值是一个long long类型的整数，这个证书保存了key所指向的数据库键的过期时间。
![[Pasted image 20231114173108.png]]

#### 过期数据的删除策略
过期数据的删除策略就两个
- 惰性删除：只会在取出key的时候才对数据进行过期检查。这样对cpu友好，但是可能造成大多过期key没有被删除。
- 定期删除：每隔一段时间抽取一批key执行删除过期key的操作。并且，redis底层会提供限制删除操作执行的时长和频率来减少删除操作对cpu时间的影响。
定期删除对内存更加友好，惰性删除对cpu更加友好。两者各有千秋，所以，redis采用的是定期删除+惰性删除/懒汉式删除。


#### redis内存淘汰机制
	相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?

redis提供六种数据淘汰策略：
1. volatile-lru(least recently used):从已设置过期时间的数据集中挑选最近最少的数据淘汰
2. volatile-ttl:从已设置过期时间的数据集中挑选将要过期的数据淘汰
3. volatile-random:从已设置做起事件的数据集中任意选择数据淘汰
4. allkeys-lru:当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用key。
5. allkeys-random:从数据集汇总任意选择数据淘汰
6. no-eviction:禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。
7. volatile-lfu:从已设置过期时间的数据集中挑选最不经常使用的数据淘汰
8. allkeys-lfu：挡内存不足以容纳新写入数据是，在键空间中，溢出最不经常使用的key。
### redis事务
#### 什么是redis事务
redis事务提供了一种将多个命令请求打包的功能。然后，再按照顺序执行打包的所有命令，并且不会被中途打断。
#### 如何使用事务
redis 可以通过 **`MULTI`，`EXEC`，`DISCARD` 和 `WATCH`** 等命令来实现事务(Transaction)功能。
MULTI命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令后，再执行所有的命令。

这个过程是这样的：

1. 开始事务（`MULTI`）；
2. 命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；
3. 执行事务(`EXEC`)。
4. discard 命令取消一个事务
5. watch 命令监听指定的key
#### redis事务支持原子性么
Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。
#### redis事务支持持久性么
Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:

- 快照（snapshotting，RDB）
- 只追加文件（append-only file, AOF）
- RDB 和 AOF 的混合持久化(Redis 4.0 新增)

与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ `fsync`策略），它们分别是：

```
appendfsync always    #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟调用fsync函数同步一次AOF文件
appendfsync no        #让操作系统决定何时进行同步，一般为30秒一次
```

AOF 持久化的`fsync`策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。

因此，Redis 事务的持久性也是没办法保证的。

#### 如何解决redis事务的缺陷
使用lua脚本

### redis性能优化
#### 使用批量操作减少网络传输
一个redis命令的执行可以简化成四步
1. 发送命令
2. 命令排队
3. 命令执行
4. 返回结果
其中，第一步和第四步好费时间之和成为round trip time（往返时间），也就是数据在网路上传输的时间
使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少trr。
另外除了能减少trr之外，发送一次命令的socket i/o成本也比较高
##### 原生批量操作命令
redis中有一些原生支持批量操作的命令，比如
- mget 获取一个或多个指定key的值
- mset  设置一个或多个指定key的值
- hmget 获取指定哈希表中的一个货多个指定字段的值
- hmset 同时将一个货多个field-value对设置到指定的哈希表中
- sadd 向指定集合添加一个或多个元素
##### pipeline
对于不支持批量操作的命令，我们可以利用pipeline将一批redis命令封装成一个组，这些redis命令会被一次性提交到redis服务器。


### redis hotkey
#### 什么是hotkey
如果一个key的访问次数比较多且明显多于其他key的话，那这个key就可以成hotkey。例如在redis实例的美妙处理请求达到5000次，二其中某个key的美妙访问量就高达2000次，那这个key就可以看做hotkey。

##### hotkey有什么危害
处理hotkey会占用大量的cpu和贷款，可能会影响redis实例对其他请求的正常处理。此外，如果突然访问hotkey超出了redis的处理能力，redis则会直接宕机。这种情况下，大量请求将落后后面的数据库上，可能会导致数据库崩溃。
因此，hotkey很可能成为系统性能的平静点，需要但对对其进行优化，以确保系统的高可用性能和稳定性。

#### 如何发现hotkey
1、使用redis自带的--hotkeys参数来查找。
2、使用monitor命令
3、借助开源项目查看

#### 如何解决hotkey
hotkey的常见处理以及优化办法如下
- 读写分离：主节点处理请求，从节点处理读请求
- 使用redis cluster：将热点数据分散存储在多个redis节点上。
- 二级缓存：hotkey采用二级缓存的方式进行处理，将hotkey存放一份到jvm本地内存中

### 慢查询命令
#### 为什么会有慢查询命令
Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：
- `KEYS *`：会返回所有符合规则的 key。
- `HGETALL`：会返回一个 Hash 中所有的键值对。
- `LRANGE`：会返回 List 中指定范围内的元素。
- `SMEMBERS`：返回 Set 中的所有元素。
- `SINTER`/`SUNION`/`SDIFF`：计算多个 Set 的交集/并集/差集。
- ……
由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 `HSCAN`、`SSCAN`、`ZSCAN` 代替。
除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：
- `ZRANGE`/`ZREVRANGE`：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- `ZREMRANGEBYRANK`/`ZREMRANGEBYSCORE`：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。
- ……

