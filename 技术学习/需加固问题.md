#### nodejs
##### 异步/同步 阻塞/非阻塞的区别
以下 ， A：调用方， B：被调用方
- 同步/异步 ： 反应A和B双方的关系，即A如何调用B
	- 同步：B被调用后等待有结果之前不返回，A等待结果返回后再进行下一步操作
	- 异步：B被调用后立即返回，A立即进行下一步，B等待结果准备好后，通过回调等方式发送给A
- 阻塞/非阻塞：反应某一时刻某个线程/进程的状态
	- 阻塞：线程/进程挂起，不接受新任务
	- 非阻塞：线程/进程空闲，接受新任务
可见，同步与阻塞是两组不同维度的概念，两组概念单独理解都比较简单，但是两两组合之后理解就比较困难，这是因为根据应用场景的不同组合后的概念也并不相同。

当用来描述一个跨进程调用（例如操作系统的I/O操作，或者B/S的Socket请求），同步指跨进程调用返回结果的方式，阻塞指被调用方准备结果时的进程状态（阻塞指被调用方）

- 同步阻塞： A发送请求之后一直等待响应。 B的结果不能马上准备好（例如需要进行一个IO操作，但不能马上等到返回结果）就一直等到返回结果后，才响应A，期间不能进行其他工作。
- 同步非阻塞： A发送请求之后，一直等待响应。 B处理请求时进行的IO操作如果不能马上的得到结果，就立即返回，去做其他事情。 但是由于没有得到请求处理结果，不响应A，A一直等待。 当IO操作完成以后，将完成状态和结果通知A，B再响应A，A进入下一次请求过程。（实际不应用）
- 异步阻塞： A向B请求后，不等待响应，可以继续其他工作。 B处理请求时进行IO操作如果不能马上得到结果，就一直等到返回结果后，才响应A，期间不能进行其他操作。 （实际不应用）
- 异步非阻塞： A向B请求后，不等待响应，可以继续其他工作。 B处理请求时进行IO操作如果不能马上得到结果，也不等待，而是马上返回去做其他事情。 当IO操作完成以后，将完成状态和结果通知B，B再响应A。（效率最高）

当描述一个跨线程调用时，同步指跨线程调用返回结果的方式，阻塞指的是调用方等待数据返回时的线程状态（阻塞指调用方）
- 同步阻塞：A发送请求后一直等待响应，等待过程中线程挂起（不接受新任务）。B任务完成后返回结果，A继续执行
- 同步非阻塞：A发送请求后不等待，线程立即可以接受新任务。B的任务完成后返回结果，A通过轮训等方式检查结果是否完成功能。
- 异步阻塞：A发送请求后B立即返回。B的结果准备好后通过回调等方式将结果发送给A。B的结果准备好之前，A处于阻塞状态。（A没有必要阻塞，所以实际不应用）
- 异步非阻塞：A发送请求后B立即返回。B的结果准备好后通过回调等方式将结果发送给A。B的结果准备好之前，A的线程可以接受新任务
##### 五种io模型
##### setTimeout和setImmediate以及process.nextTick
##### 面对对象原则

#### web前端
#### 数据库/缓存/队列
#### 计算机网络
#### docker/devops

