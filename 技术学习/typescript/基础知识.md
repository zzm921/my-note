### 基础类型
#### 基础类型总结
- 布尔值：boolean
- 数字：number
- 字符串：string
- 数组： Array<> number[]   
- 元组Tuple:[string,number]
- 枚举：enum 
- Any：任意类型
- Void：void类型像是与any类型相反，它表示没有任何类型。 当一个函数没有返回值时，你通常会见到其返回值类型是 void
- Null和Undefined：不建议使用
- Never：never类型表示的是那些永不存在的值的类型。 例如， never类型是那些总是会抛出异常或根本就不会有返回值的函数表达式或箭头函数表达式的返回值类型； 变量也可能是 never类型，当它们被永不为真的类型保护所约束时。
- Object：object表示非原始类型，也就是除number，string，boolean，symbol，null或undefined之外的类型。
#### 类型断言
有时候你会遇到这样的情况，你会比TypeScript更了解某个值的详细信息。 通常这会发生在你清楚地知道一个实体具有比它现有类型更确切的类型。
通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript会假设你，程序员，已经进行了必须的检查。
类型断言有两种形式：
``` 
尖括号类型断言
let someValue:any='this'
let strLength:number = (<string>someValue).length
as 语法类型断言
let someValue:any='this'
let strLength:number = (someValue as string).length
```
### 变量声明
使用let/const代替var
#### let vs const
使用最小特权原则，所有变量除了你计划去修改的都应该使用const。

### 接口
TS的核心原则之一是对值所具有的结构进行类型检查。它有时被称做“鸭式辨型法”或“结构性子类型化”。在TypeScript里，接口的作用就是为这些类型命名和为你的代码或第三方代码定义契约。

#### 基础类型
```
interface LabelledValue {
  label: string;
}

function printLabel(labelledObj: LabelledValue) {
  console.log(labelledObj.label);
}

let myObj = {size: 10, label: "Size 10 Object"};
printLabel(myObj); 
```

##### 接口属性类型
- 可选属性： `interface LabelledValue {label?: string}`
- 只读属性：`interface LabelledValue {readonly label: string}`

#### 函数类型
```
接口定义函数类型
interface SearchFunc{
	(source:string, subString: string):boolean;
}
let mySearch: SearchFunc;
mySearch = function(source: string, subString: string) {
  let result = source.search(subString);
  return result > -1;
}
```

#### 可索引类型
与使用接口描述函数类型差不多，我们也可以描述那些能够“通过索引得到”的类型，比如a[10]或ageMap["daniel"]。 可索引类型具有一个 索引签名，它描述了对象索引的类型，还有相应的索引返回值类型。
```
interface StringArray{
	[index:number]:string;
}

let myArray: StringArray;
myArray = ["Bob", "Fred"];

let myStr: string = myArray[0];
```
TypeScript支持两种索引签名：字符串和数字。 可以同时使用两种类型的索引，但是数字索引的返回值必须是字符串索引返回值类型的子类型。 这是因为当使用 number来索引时，JavaScript会将它转换成string然后再去索引对象。

#### 类类型
```
# 定义一个类 类型
interface ClockInterface{
	currentTime:Date
}
# 实现这个类
class Clock implements ClockInterface {
    currentTime: Date;
    constructor(h: number, m: number) { }
}
```
接口描述了类的公共部分，而不是公共和私有两部分。 它不会帮你检查类是否具有某些私有成员。

#### 继承接口
```
interface Shape {
    color: string;
}

interface Square extends Shape {
    sideLength: number;
}

let square = <Square>{};
square.color = "blue";
square.sideLength = 10;
```

#### 混合类型
```
interface Counter {
    (start: number): string;
    interval: number;
    reset(): void;
}

function getCounter(): Counter {
    let counter = <Counter>function (start: number) { };
    counter.interval = 123;
    counter.reset = function () { };
    return counter;
}

let c = getCounter();
c(10);
c.reset();
c.interval = 5.0;
```
#### 接口继承类
当接口继承了一个类类型时，它会继承类的成员但不包括其实现。 就好像接口声明了所有类中存在的成员，但并没有提供具体实现一样。 接口同样会继承到类的private和protected成员。 这意味着当你创建了一个接口继承了一个拥有私有或受保护的成员的类时，这个接口类型只能被这个类或其子类所实现（implement）。

当你有一个庞大的继承结构时这很有用，但要指出的是你的代码只在子类拥有特定属性时起作用。 这个子类除了继承至基类外与基类没有任何关系。
```
class Control {
    private state: any;
}

interface SelectableControl extends Control {
    select(): void;
}

class Button extends Control implements SelectableControl {
    select() { }
}

class TextBox extends Control {
    select() { }
}

// 错误：“Image”类型缺少“state”属性。
class Image implements SelectableControl {
    select() { }
}

class Location {

}
```
### 类
- 类：定义了一件事物的抽象特点，包含它的属性和方法
- 对象 ：类的示例，通过new生成
- 面对对象的三大特性：封装、继承、多台
- 封装：对数据的操作细节隐藏起来，只暴露对外的接口。外接调用端不需要知道细节，就能同各国对外提供的接口来访问该对象，同事也保证了外接无法任意改变对象内部的数据
- 继承：子类继承父类，子类除了拥有父类所有特性外，还有一些更具体的特性
- 多态：有继承而产生了相关的不同的类，对同一个方法可以有不同的相应。
- 存取器：用以改变属性的读取和复制行为
- 修饰符：修饰符是一些关键词，用于限定成员或类型的性质。如public表示公有属性或方法
- 抽象类：抽象类是供其他类继承的基类，抽象类不允许被实例化。抽象类中的抽象方法必须在子类中被实现
- 接口：不同类之间共有的属性或方法，可以抽象成一个接口。接口可以被类实现。一个类智能集成自另一个类，但可以实现多个接口。
### 函数
```
1.
 let myAdd: (x: number, y: number) => number =
    function(x: number, y: number): number { return x + y; };

2、
let myAdd = function(x: number, y: number): number { return x + y; };

// The parameters `x` and `y` have the type number
let myAdd: (baseValue: number, increment: number) => number =
    function(x, y) { return x + y; };
    
```
### 泛型
```
function identity<T>(arg: T): T {
    return arg;
}
let output = identity<string>("myString");
let output = identity("myString"); 
```
我们给identity添加了类型变量T。 T帮助我们捕获用户传入的类型（比如：number），之后我们就可以使用这个类型。 之后我们再次使用了 T当做返回值类型。现在我们可以知道参数类型与返回值类型是相同的了。 这允许我们跟踪函数里使用的类型的信息。
#### 泛型变量
```
function loggingIdentity<T>(arg: T): T {
    console.log(arg.length);  // Error: T doesn't have .length
    return arg;
}

function loggingIdentity<T>(arg: T[]): T[] {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}

function loggingIdentity<T>(arg: Array<T>): Array<T> {
    console.log(arg.length);  // Array has a .length, so no more error
    return arg;
}

```
#### 泛型类型
```
function identity<T>(arg: T): T {
    return arg;
}

let myIdentity: <T>(arg: T) => T = identity;
let myIdentity: {<T>(arg: T): T} = identity; 字面量形式
```
#### 泛型类
```
class GenericNumber<T> {
    zeroValue: T;
    add: (x: T, y: T) => T;
}

let myGenericNumber = new GenericNumber<number>();
myGenericNumber.zeroValue = 0;
myGenericNumber.add = function(x, y) { return x + y; };
```
#### 泛型约束
```
interface Lengthwise {
    length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
    console.log(arg.length);  // Now we know it has a .length property, so no more error
    return arg;
}


class BeeKeeper {
    hasMask: boolean;
}

class ZooKeeper {
    nametag: string;
}

class Animal {
    numLegs: number;
}

class Bee extends Animal {
    keeper: BeeKeeper;
}

class Lion extends Animal {
    keeper: ZooKeeper;
}

function createInstance<A extends Animal>(c: new () => A): A {
    return new c();
}

createInstance(Lion).keeper.nametag;  // typechecks!
createInstance(Bee).keeper.hasMask;   // typechecks!
```
### 枚举
#### 数字枚举
```
enum Direction {
    Up = 1,
    Down,
    Left,
    Right
}
```