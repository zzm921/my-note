### nodejs简介
#### node的特点
- 异步io
- 事件与回调函数
- 单线程
- 跨平台
### 模块机制
#### commonJs规范
commonjs规范为js制定了一个美好的远景-希望js能在任何地方运行
##### commonjs的模块规范
- 模块引用 ：使用require引入模块
- 模块定义
- 模块标识
#### node模块实现
node引入模块需要三个步骤
1. 路径分析
2. 文件定位
3. 编译执行
模块分为两类：一类是node提供的模块，成为核心模块；另一类是用户编写的模块，称为文件模块。
- 核心模块部分在node源码的编译过程中，编译进了二进制文件。在node启动时加载进入内存中。
- 文件模块在运行是动态加载，需要完整的三个步骤。
##### 优先从缓存加载
node同一个模块第二次加载优先从缓存中加载
##### 路径分析和文件定位

##### 模块编译
在node中，每一个文件模块就是一个对象，他的定义如下
```
function Module(id,parent){
	this.id=id
	this.exports={}
	this.parent=parent
	if(parent&&parent.children){
		parent.children.push(this)
	}
	this.filename=null
	this.loaded=fale
	this.children=[]
}
```
定位到具体文件后，node会新建一个模块对象，根据路径载入并编译。对于不同的文件拓展名编译方式不同
- .js  通过fs模块读取文件后编译执行
- .node  这是用c/c++编写的文件拓展名，通过dlopen（）方法加载后编译生成文件
- .json 使用json.parse()
每个编译成功的模块都会将其文件路径作为索引缓存在 `Module._cache` 对象上，以提高二次引入的性能。
###### js模块的编译
我们知道每个模块文件都有require，exports，module这三个变量，但是模块定义并没有。事实上，在编译过程汇总，node对获取js文件内容进行头尾包装，在头部和尾部添加部分代码。添加后如下
```
(function(exports,require,module,__filename,__dirname){
	xxx模块代码
};
```
这样每个模块之间的作用域是相互隔离的。包装后通过vm原生模块的runInThisContext()方法执行，返回一个function对象。最后将export ，require ，module传入这个function执行。
###### c++模块编译
###### json文件编译
#### 核心模块
##### js核心模块编译过程
在编译所有的c/c++文件之前，编译程序需要将所有的js模块文件编译为c/c++代码。
- 转为c/c++代码。node使用v8附带的js2c.py工具，将所有内置js代码(src/node.js和lib/*.js*)转换为c++里面的数组，生成node_natives.h头文件。
- 编译js核心模块。首先在引入js的核心模块的过程中，经历了模块包装器的过程，然后 到处exports对象。js核心模块源文件通过process.binding('natives')去除，编译成功后模块缓存在NativeMode._cache,文件模块则缓存在Module._cache。
```
function NativeModule(id){
	this.filename=id+'.js'
	this.id=id
	this.exports={}
	this.load=false
}
NativeModule._source=process.binding('catives')
NativeModule._cache={}
```
##### c++核心模块编译过程
Node的高性能，很大程度是因为核心模块，多数有c/c++编写，c++模块主内完成核心，js模块主外实现封装模块，充分利用了脚本语言一边写，c、c++高效执行的有点。常见的 buffer,crypto,evals,fs,os等都是c++写的。
#### 核心模块引入流程
![[Pasted image 20231012172635.png]]
```
require(os)->NativeModule.require(os)->process.binding(os)->get_builtin_module(node_os)->NODE_MODEUL(node_os,reg_func)
```
#### 模块调用栈
![[Pasted image 20231012172923.png]]
#### 包与npm
node中，包和npm是将模块关联在一起的一种机制。commonjs规范中包目录应该包含如下这些文件。
1. package.json：包描述文件
2. bin:可执行的二进制文件
3. lib：存放js文件
4. doc：存放文档目录
5. test：单元测试代码
### 异步i/0
异步的概念首先在web2.0中火起来，因为浏览器中的js是在单线程执行，而且他还余ui渲染共用一个线程。这意味着js在执行的时候ui渲染和响应是处于停止状态的。前端通过异步的方式来消除ui阻塞现象

异步 I/O 就是 I/O 的调用不再阻塞后续计算，将原有等待 I/O 完成这段时间分配给其它需要的业务去执行。
#### 异步i/o实现现状
##### 异步i/o和非阻塞i/o
异步/同步和阻塞/非阻塞并不是同一件事
操作系统内核对于i/o只有两种方式：阻塞和非阻塞
- 阻塞i/o。调用后一定要等到系统内核层面完成所有操作，调用才结束。
- 非阻塞i/o。调用后立即会返回。由于立即返回的并不是业务层期望的数据，而仅仅是当前的调用状态。为了获取完整的数据，应用程序需要重复调用i/o操作来确认是否完成。这种重复调用的技术叫做轮询。
###### 轮询技术
- read。他是最原始的、性能最低的一种，通过重复调用来检查i/o状态来完成完整数据对的读取。在得到最终数据钱，cpu一直耗在等待上
- select。他是在read的基础上进行了改进。通过对文件描述符上的事件状态来进行判断。select 轮询采用 1024 长度数组存储状态。
- poll。是select方案的该井，采用链表的方式避免数组长度的限制，其次他能避免不必要的检查
- epoll。该方案是linux下最高的i/o时间通知机制，在进入轮询的时候如果没有检查到i/o事件，将会进行休眠，直到事件发生将其唤醒。他是真实利用了事件通知、执行回调的方式，而不是遍历查询，所以不会浪费cpu，执行效率高
- kqueue。该方案的实现方式与epoll类似，不过他只在freebsd上存在
##### 理想的非阻塞异步i/o
尽管epoll已经利用了事件来降低cpu的消耗，但是休眠时间的cpu是闲置的。对于当前线程而言利用率不高。
#### node的异步i/o
##### 事件循环
node自身的执行模型-事件循环 ，正式他是的回调函数十分普遍。
在启动进程时，node会创建一个类似while的循环，每次执行循环体的过程我们叫做tick。每个tick过程就是查看是否有事件待处理，如果有，就取出时间相关回调函数。如果存在关联的回调函数，就执行他们，然后进入下一个循环。如果不再有事件就退出。
##### 观察者
每个tick通过观察者来判断事件是否需要处理。每个事件循环有一个或者多个观察者，而判断是否有事件需要处理的过程就是向观察者询问是否有事件需要处理。

事件主要来源于网络请求，文件i/o等，这些事件对应的观察者有文件i/o观察者、网络i/o
观察者等。观察者将事件进行分类

事件循环是一个典型的生产者/消费者模型。异步i/o,网络请求是事件的生产者，源源不断的为node提供不同的事件，这些事件被传递到观察者那里，事件循环则从观察者那里取出事件并处理。

##### 请求对象
对于node的异步i/o调用而言，回调函数不由开发者来调用。从js发起调用到内核执行完成i/o操作的过度过程中，存在一中中间产物，叫做请求对象。
请求对象是异步i/o过程的重要产物，所有的状态都保存在这个对象中，包括送入线程池等待执行以及i/o操作完毕后的回调处理。
比如下述代码，当文件打开成功后，后面的回调的执行过程是怎样的呢？
```
const fs =require('fs')
fs.opne(xxx.js,a+,callback)
```
从js调用node核心模块，核心模块盗用c++内建模块，内建模块通过libuv尽心系统调用。libuv作为封装层，有各个平台的实现，本质上是调用了uv_fs_oepn()方法。调用uv_fs_open()方法的过程中，我们创建了一个FSReqWrap请求独享。从js层传入参数和当期那方法都封装在这个请求对象中，回调函数也是这个请求对象的属性。而操作系统拿到这个对象后，价格FSReqWrap对象推入线程池中等待执行。
至此，js回调立即返回，异步调用第一步完成，js线程可以继续执行后续任务。当前的i/o操作在线程池中等待执行，不管他是否阻塞，都不会影响js后续的执行。

##### 执行回调

线程池中的请求在得到cpu资源后调用操作系统底层的函数来完成io操作，线程池调用PostQueuedCompletionStatus()方法提交状态，然后将结果存储在请求对象的req->resule属性上，并释放线程回归线程池。i/o观察值在每次tick的时候调用getQueuedCompletionStatus()方法检查线程池中是否有执行完成的请求，如果存在，会将请求对象加入到i/o观察者队列中，然后当做事件将其处理。

i/o观察者去除请求对象的result属性作为参数，去除绑定在上面的会ID哦啊函数，然后执行，以此达到调用js回调函数的目的。至此整个异步i/o完成。
![[Pasted image 20231012174739.png]]
事件循环、观察者，请求对象、i/o线程池这四者共同组成了node异步i/o模型。windows主要通过iocp来向系统内核发送i/o调用和从系统内核中获取i/o状态，配已事件循环，完成异步i/o过程。linux下通过epoll实现这个过程。不同的时候，线程池在windows上由内核iocp实现，linux下由libuv实现。

#### setTimeout  setInterval  setImmeiate process.nextTick
##### 定时器
（1）setTimeout和setInteravl的实现原理与异步i/o比较类似，只需不需要线程参加。调用这两个创建的定时器会被插入定时器观察者内部的红黑树中，每次tick执行时。会从该红黑树中迭代选出定时器对象，检查是否超时，如果超时啧立即执行。

执行回调函数的是定时器观察者。

定时器的问题在于，他并非精确，尽管时间循环非常快，但是如果每次循环占用时间比较多，那么下次循环时他可能超时很久了。
![[Pasted image 20231012175409.png]]
（2）process.nextTick()的出现正式为了拮据定时器精度不高，并且需要红黑树(性能浪费)的问题。他的作用是定一个一个动作，在下次事件轮询的时间点上执行这个动作。
比如：

function foo () {  <br>  console.log('aaa')    <br>}  <br>process.nextTick(foo)  <br>console.log('bbb')|

终端上的输出结果是：
bbb  <br>aaa

使用 setTimeout 也能达到同样的效果：

function foo () {  <br>  console.log('aaa')    <br>}  <br>setTimeout(foo, 0)  <br>console.log('bbb')|

每次调用 process.nextTick() 方法，只会将回调函数放入队列中，在下一轮 Tick 时取出执行。  
定时器中采用红黑树的操作时间复杂度为 O(lg(n))，nextTick() 的时时复杂度为 O(1)。相比之下，  
process.nextTick() 更高效。

(3)setImmediate() 与 process.nextTick() 方法十分类似，都是将回调函数延迟执行。

process.nextTick(function () {  <br>  console.log('延迟执行')  <br>})  <br>console.log('正常执行')  <br>//----------//  <br>setImmediate(function () {  <br>  console.log('延迟执行')  <br>})  <br>console.log('正常执行')

两者的输出结果是一样的：

	正常执行  <br>延迟执行

process.nextTick 的优先级要高于 setImmediate。原因是事件循环对观察者的检查是有先后顺序的。process.nextTick 属于 idle 观察者，setImmediate 属于 check 观察者。在每一个轮询检查中，idle 观察者优先于 I/O 观察者，I/O 观察者优先于 check 观察者。

还有一个主要的区别是，process.nextTick() 的回调函数保存在数组中，setImmediate() 的回调函数保存在链表中。在行为上，process.nextTick() 在每次轮询中会将数组内全部回调函数执行完，setImmediate() 在每次循环中只执行链表的第一个回调函数。
还有一个主要的区别是，process.nextTick() 的回调函数保存在数组中，setImmediate() 的回调函数保存在链表中。在行为上，process.nextTick() 在每次轮询中会将数组内全部回调函数执行完，setImmediate() 在每次循环中只执行链表的第一个回调函数。
### 异步编程
#### 函数式编程
在js中，函数作为一等功公民，使用上非常自由，无论调用它，或者是作为参数或者作为返回值都可以。函数的灵活性是js比较吸引人的地方之一
##### 高阶函数
通常语言中，函数的参数只接受基本的数据类型或者是对象引用，返回值也基本是数据类型和对象引用。高阶函数则是可以把函数作为参数，或是将行数作为返回值的函数。
##### 偏函数
偏函数的用法是指创建一个调用另外一部分 ”参数或者变量已知的估值好的函数“ 的函数的用法。
```
var isType=function(type){
	return function(obj){
		return toString.call(obj)==`[object ${type}]`
	}
}
var isString =isType(string)
vat isFunction = isType(function)
```
通过引入isType，创建isString和isFunction就简单多了，这种通过制定部分参数来产生一个新的定制函数的形式就是偏函数。
<<<<<<< HEAD
#### 异步编程的优势和难点
##### 优势
Node带来的最大特性莫过于基于事件驱动的非阻塞i/o模型，非阻塞i/o可以使cpu与i/o并不互相依赖等待，让资源得到更好的利用。
只要合理的利用node的异步模型和v8的高性能，就可以充分发挥cpu和i/o资源的优势。
##### 难点
难点1、异常处理
异步i/o的实现主要包括两个阶段，提交请求和处理结果。这两个阶段中间有事件循环的调度，两者彼此不关联。异步方法则通常咋以第一个阶段请求后立即返回，因为异常并不一定发生在这个阶段，trycatch在此处发挥不来功效。

node在异常处理上形成了一种约定，将异常作为回调函数的第一个实参传回，如果为空值，则表明异步调用没有抛出异常。

编写异步方法的原则
1、必须执行调用者传入的回调参数
2、正确传递异常工调用者判断
难点2、函数嵌套过深
难点3、阻塞代码
难点4、多线程编程
难点5、异步转同步

#### 异步编程解决方案（？）
- 事件发布订阅模式
- promise/deferred模式
- 流程控制库
#### 异步并发控制

### 内存控制
#### v8的垃圾回收机制与内存限制
##### v8的内存限制
node中通过js使用内存只能使用部分内存(64位系统为1.4g,32位系统为0.7g),造成这个问题的主要原因在于，node中的js对象基本都是通过v8自己的方式来进行分配和管理。
##### v8的对象分配
在v8中，js对象都是用过堆来分配的。node可已通过process.memoryUsage()查看属性，使用这个命令返回三个属性，heapTotal和heapUsed标识v8的堆内存使用情况，前者标识申请的堆内存，后者是当前的使用量。rss

当我们在代码中声明变量并赋值时，所使用对象的内存就分配在堆中。如果已申请的堆空闲内存不足够分配新的对象，则会继续申请，直到到上限。

v8限制内存的原因是，因为1.5g的内存够，v8做一次垃圾回收需要50ms，做一次非增量的垃圾回收甚至要超过1s以上。这是垃圾回收引起js线程暂停执行的事件，在这样的时间花销下，应用的性能和相应能力都会直线下降。
可以通过
--max-old-space-size=xxx
--max-new-space-size=xxx 
调整内存限制大小
##### v8的垃圾回收机制
###### v8的垃圾回收算法
v8的垃圾回收策略主要是基于分代式垃圾回收机制。
在v8中，主要将内存分为新生代和老生代，新生代中的对象为存活时间较短的对象，老生代中的对象为存活时间较长或常驻内存的对象。
###### scavenge
新生代中的对象主要通过scavenge算法进行垃圾回收，一种采用复制方式实现的垃圾回收算法。他将堆内存分为两部分，每部分空间成为semispace。在这两个simispace空间中，只有一个处于使用，使用状态的称为from空间，空闲状态称为to空间。分配对象会在from空间中分配，当开始进行垃圾回收时，会检查from空间中的存货对象，复制到to空间，非存活对象则会被删除。然后from空间和to空间角色对换。

###### mark-sweep和mark-compact
mark-sweep是标记清除的意思，它分为标记和清除两个阶段。mark-sweep在标记阶段遍历堆中的所有对象，并标记活着的对象，在随后的清除阶段，只清除没有被标记的对象。
mark-sweep最大的问题是在进行一次标记清除后，内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题，因为很有可能出现需要分配一个大对象的情况，这时所有的内存碎片空间都无法满足。就会提前触发垃圾回收

mark-compact是标记整理的意思，是在标记清除的基础上演变而来。他们的差别在于对象在标记为死亡后，在整理的过程中，将活着的对象向一端移动，移动完成后直接清理另一端的内存。

v8主要使用的是mark-sweep，在空间不足以对从新生代晋升过来的对象进行分配时，才使用mark-compact

######  Incremental Marking
为避免js逻辑应用与垃圾回收器看到的不一致的情况，垃圾回收的三种算法都需要将应用停下来，待执行完垃圾回收后再继续执行应用逻辑，这种行为被称为全停顿。

为了降低全队垃圾回收带来的停顿事件，v8先从标记阶段入手，将原本需要一口气停顿完成的动作改成增量标记，也就是拆分许多小‘步进’，每做完一个步进就让js执行一小会，垃圾回收和应用逻辑交替执行直到标记阶段完成。

##### 查看垃圾回收日志
启动时增加--trace_gc
	node --trace_gc xxx.js


#### 高效使用内存
##### 作用域
##### 闭包
js实现从外部作用域访问内部作用域的方法叫做闭包

#### 内存指标
#### 内存泄漏

### 理解buffer
#### Buffer的构造
Buffer是一个array对象，但他主要是操作字节。buffer是一个典型的js与c++结合的模块，她将性能相关的部分用c++实现，将费新能相关的部分用js实现。

buffer 所占的内存不是通过v8分配的，而是堆外内存。由于v8的垃圾回收的性能影响，将buffer对象用更搞笑的专有内存分配回收策略来管理。

buffer在node进程启动的时候已经载入，并将其放在全局对象global上，因此无需require就能使用
##### 模块结构
##### Buffer对象
Buffer对象类似于数组，他的元素是16进制的两位数，即0-225的数值
##### buffer内存分配
Buffer对象的内存分配不是v8的堆内存中，而是在nodec++层实现内存申请的。
不同编码的字符串占用的元素个数各不相同，中文在utf-8编码下占用3个元素，字母和半标点占用1个元素。

Buffer 可以通过 length 属性得到长度，也可以通过下标访问元素。
```
var buf = new Buffer(100)
console.log(buf.length) // 100
console.log(buf[10]) // 0
buf[10] = 100  
console.log(buf[10]) // 100
```
如果给元素赋值不是 0 到 255 的整数而是小数，Buffer 通过不断 +256 或者不断 -256 得到一个位于 0 - 255 之间的整数。如果是小数，则直接舍弃小数部分，只保留整数部分。
```
buf[10] = -100  
console.log(buf[10]) // 156  
buf[10] = 300  
console.log(buf[10]) // 44  
buf[10] = 3.1415  
console.log(buf[10]) // 3
```
#### buffer内存分配
buffer对象的内存不是在v8的堆内存中，而是node的c++层面实现内存申请。因为处理大量的字节数据不能采用需要一定内存就向操作系统申请一点内存的方式，这可能造成大量内存申请的系统调用，对操作系统有一定压力。node使用测策略是在c++层面申请内存，在js中分配内存。

node操作buffer使用slab内存分配策略，slab是一种动态内存管理机制。
slab是一块申请号的固定大小的内存区域。一共有三种状态：full-完全分配，partial-部分分配，empty-没有分配。

当我们需要一个buffer对象，可以用过传入size来指定buffer对象的大小

node以8k为接线来区分buffer是大对象还是小对象。这个8k也就是每个slab的值，在js层面，一他作为单位进行内存分配。
1、小buffer对象
如果指定 Buffer 的大小小于 8kb，Node会按照小对象的方式进行分配。 
2、大 Buffer 对象
如果是超过 8kb 的对象，将会直接分配一个 SlowBuffer 对象作为 slab 单元，这个 slab 单元将被这个大 Buffer 对象独占。
#### buffer转换
buffer对象可以与字符串直接相互转换，目前支持的字符串编码类型有：ASCII、UTF-8、UTF-16LE/USC-2、Base64、Binary、Hex。
#### 字符串转buffer
字符串可以通过buffer构造函数转为buffer对象，存储的只能说一种编码。encoding参数不传递时默认使用utf-8编码进行转码和存储。一个buffer对象可以存储不同编码类型的字符串转码的值，调用write可以实现。 
>>>>>>> 2f67678b7d0274aac0ca9e2d4d2f173a99d1ecf9
