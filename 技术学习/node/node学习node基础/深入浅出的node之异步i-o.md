####架构


nodejs结构分为三部分
- node.js标准库
- node bindings ：node程序的main函数入口，还有提供给lib模块的c++类接口，这一层是JavaScript与底层c/c++沟通的桥梁
- 最底层，支持node运行的关键，v8引擎：用来解析、执行javas代码的运行环境。 libuv：提供最底层的io操作接口，包括文件异步id的线程池管理和网络的io操作，是整个异步io的核心
小结：
node的‘单线程’指的是我们（开发者）编写的代码只能运行在一个线程中（主线程），node并没有给JavaScript执行时创建新线程的能力，所以称为单线程。也就是所谓的主线程。其实，node中许多异步方法在具体的实现时（node底层疯转了libuv，它提供了线程池，事件池，异步i/o等模块功能，其王城了异步方法的具体实现），内部均采用了多线程机制。
####异步io


主线程为用户JavaScript代码运行的线程。
####node运行流程


- node启动，进入main函数
- 初始化核心数据接口default_loop_struct；这个数据结构是事件循环的核心，档node执行到‘加载js文件’时，如果用户的JavaScript代码中有异步io操作是，这个时候，js代码动用->lib模块->c++模块->libuv接口->最终系统底层api->系统返回一个文件描述符fd和js代码传进来的回调函数，然后封装成一个io观察者（uv_io_s对象），保存到default_loop_struct。
（文件描述符的理解： 对于每个程序系统都有一张单独的表。精确地讲，系统为每个运行的进程维护一张单独的文件描述符表。当进程打开一个文件时，系统把一个指向此文件内部数据结构的指针写入文件描述符表，并把该表的索引值返回给调用者 。应用程序只需记住这个描述符，并在以后操作该文件时使用它。操作系统把该描述符作为索引访问进程描述符表，通过指针找到保存该文件所有的信息的数据结构。）
（观察者的理解：在每个Tick（在程序启动时，Node便会创建一个类似于while(true)的循环，没执行一次循环体的过程我们称为Tick）的过程中，为了判断是否有事件需要处理，所以引入了观察者的概念，每个事件循环中有一个或多个观察者，判断是否有事件要处理的过程就是向这些观察者询问是否有要处理的事件。在node中，事件主要来源于网络请求，文件IO等，这些事件对应的观察者有文件I/O观察者、网络I/O观察者等。事件轮询是一个典型的生产者、消费者模型，异步I/O、网络请求等则是事件的生产者，源源不断为node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。）

- 加载用户的js文件，调用v8引擎接口，解析并执行js代码，如有异步io，则通过一系列调用系统底层api。若是网络io，把系统调用后返回的结果和事件绑定的回调函数一起封装成一个io观察者，保存到default_loop_struct中。如果试文件io，我们创建了一个fsreqwrap请求对象，从js层传入的参数和当前方法都被封装在这个请求对象中，其中我们最为福安心的是回调函数则被设置在这个对象的oncomplete_sym属性上：req_wrap->object_->Set(oncomplete_sym, callback)；对象包装完毕后，在win下则调用QueueUserWorkItem()方法将FSReqWrap对象推入线程池中等待执行。该方法的代码如下所示QueueUserWorkItem(&uv_fs_thread_proc, req, WT_EXECUTEDEFAULT)；QueueUserWorkItem()方法接收3个参数：第一个参数是将要执行的方法的引用，这里引用的是uv_fs_thread_proc，这个参数是uv_fs_thread_proc运行时所需要的参数；第三个参数是执行的标志。当线程池中有可用线程时，我们会调用uv_fs_thread_proc()方法。uv_fs_thread_proc()方法会根据传入参数的类型调用相应的底层函数。以uv_fs_open()为例，实际上调用的是fs__open()方法。
至此，js调用立即返回，有js层面发起的异步调用的第一阶段就此结束。js线程可以继续之前当前任务的后续操作。当前的i/o操作在线程池中等待执行，不管他是否会阻塞io，都不会影响到js线程的后续执行，如此就达到了异步的目的。
- 进入事件循环，即调用libuv的时间循环入口函数uv_run()；但处理完js代码，如果有io擦欧洲，那么这是default_loop_struct是保存着对应的io观察者的，处理完js代码，main函数继续往下调用libuv的事件循环入口uv_run()，node京城进入事件循环：
uv_run()的while循环做的第一件事，判断defaule_loop_struct是否有存货的io观察者
    * 如果没有io观察值，那么ub_run（）退出，node进程对出

    * 如果有观察者，那么uv_run（）进入epoll_wait()，线程挂起等待，监听对应的io观察者是否有数据到来，有数据到来调用观察者里保存着的callback，没有数据到来时一直在epoll_wait()进行等待。




