### nodejs里面的模块
nodejs中每个模块都是一个对象，定义如下
```
function Module(id,parent){
	this.id = id; 
	this.exports = {};
	this.parent = parent; 
	this.filename = null; 
	this.loaded = false; 
	this.children = [];
}
module.exports=Module

var module = new Module(filename, parent);
```

### require 模块加载机制
1. 先计算模块的路径
2. 查看是否有缓存，如果有缓存则取出缓存
3. 加载模块
4. 输出模块的exports属性


### exports和 module.exports的区别
exports和module.exports本质上指向同一个对象。

如果要输出一个键值对象{}，可以利用exports这个已存在的空对象{}，并继续在上面添加新的键值；
如果要输出一个函数或数组，必须直接对module.exports对象赋值。
所以我们可以得出结论：
直接对module.exports赋值，可以应对任何情况： 
module.exports = { foo: function () { return 'foo'; } }; 
或者： module.exports = function () { return 'foo'; };
最终，我们强烈建议使用module.exports = xxx的方式来输出模块变量，
这样，你只需要记忆一种方法。

### node的异步IO
#### 事件循环的流程
- 进程启动时，node会创建一个类似while(true)的循环，每执行一次循环的过程我们称为一个tick
- 每个Tick的过程就是查看是否有事件待处理。如果有就取出事件及其相关的回调函数。然后进入下一个循环，如果不再有事件处理，就退出进程。
![[Pasted image 20221010105822.png]]
#### 每个tick如何判断有事件需要处理
- 每个事件循环中有一个或多个观察者，通过向观察者询问是否有事件需要处理了来判断。
- 在Node中，事件主要来源于网络请求、文件的I/O等，这些事件对应的观察者有文件I/O观察者，网络I/O的观察者。
-   事件循环是一个典型的生产者/消费者模型。异步I/O，网络请求等则是事件的生产者，源源不断为Node提供不同类型的事件，这些事件被传递到对应的观察者那里，事件循环则从观察者那里取出事件并处理。
- 在windows下，这个循环基于IOCP创建，在*nix下则基于多线程创建

#### 描述一下整个异步流程
![[Pasted image 20221010110212.png]]
### 垃圾回收
新生代：存活时间较短，scavenge算法回收。将内存一分为二。
当开始垃圾回收的时候，会检查From空间中的存活对象，这些存活对象将被复制到To空间中，而非存活对象占用的空间将会被释放。完成复制后，From空间和To空间发生角色对换。

老生代：存活时间较长，标记清除的垃圾回收算法。标记活着的对象，清除死亡的对象。


闭包和全局变量会导致内存无法回收。


### 进程
进程`Process`是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 `node app.js` 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。

child_process活着cluster创建子进程


### 框架对比
express  主要由connect中间件基于回调，并且自身封装路由、视图处理等功能
koa1 基于co中间件，框架自身不包含任何中间件，需要借助第三方中间件解决问题。基于generator特性控制异步流程。
koa2 基于async/await
- express内置了许多中间件可供使用，而koa没有。
- express包含路由，视图渲染等特性，而koa只有http模块。
- express的中间件模型为线型，而koa的中间件模型为U型，也可称为洋葱模型构造中间件。
- express通过回调实现异步函数，在多个回调、多个中间件中写起来容易逻辑混乱。

### 什么是线程池，nodejs中哪个库处理它
 线程池由 libuv 库处理。libuv 是一个多平台 C 库，它支持基于异步 I/O 的操作，例如文件系统、网络和并发。

### 异步和非阻塞的区别


### 节流防抖
1.  函数防抖：将多次操作合并为一次操作进行，原理是维护一个计时器，后设置的定时器会取代之前的定时器，如果高频事件一直在触发那么回调函数一直不会执行。
2.  函数节流：使得一定时间内只触发一次函数。原理是通过判断是否满足限制时间，满足则执行。

### 数据库分库分表
横向拆分：横向拆分的结果是数据库表中的数据会分散到多张分表中，使得每一个单表中的数据的条数都有所下降。比如我们可以把不同的用户的订单分表拆分放到不同的表中。
纵向拆分：纵向拆分的结果是数据库表中的数据的字段数会变少，使得每一个单表中的数据的存储有所下降。比如我可以把商品详情信息、价格信息、库存信息等等分别拆分到不同的表中。

### symbol
Symbols 是 JavaScript 最新推出的一种基本类型，它被当做对象属性时特别有用。
-   symbols 是一种无法被重建的基本类型。这时 symbols 有点类似与对象创建的实例互相不相等的情况，但同时 symbols 又是一种无法被改变的基本类型数据。这里有一个例子：

```ini
const s1 = Symbol();
const s2 = Symbol();
console.log(s1 === s2); // false
```

  